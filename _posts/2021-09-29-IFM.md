---
title: "[자격증] 정보처리기사 핵심요약"
excerpt: "2021 정기 3회 실기시험 준비"

categories:
  - etc
tags:
  - [정보처리기사, 실기시험]

toc: true
toc_sticky: true

date: 2021-09-29
last_modified_at: 2021-09-29
---

## 변수와 기억 클래스
### 변수
- 컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간, 변할 수 있는 값을 의미
- 저장하는 값에 따라 정수형, 실수형, 문자형, 포인터형 등으로 구분

### 기억 클래스
- 변수 선언 시 메모리 내 변수의 값을 저장하기 위한 기억영역이 할당되는데, 기억영역에 따라 사용 범위에 제한이 있다. 이러한 기억 영역을 결정하는 작업을 지칭
- c언어에서 제공하는 기억 클래스의 종류
  - 자동변수 : 함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수
  - 외부변수 : 현재 파일이나 다른 파일에서 선언된 변수나 함수를 참조하기 위한 변수
  - 정적변수 : 함수나 블록 내에서 선언하는 내부, 함수 외부에서 선언하는 외부 정적변수가 있다
  - 레지스터변수 : 메모리가 아닌 CPU내부의 레지스터에 기억영역을 할당받는 변수

![image](https://user-images.githubusercontent.com/81230679/135219539-84a6a6a4-23e3-4ee5-a780-870401699c1d.png)

<hr>

## Java의 표준 입.출력
- 키보드로 입력받은 값을 변수에 저장하려면 먼저 Scanner클래스를 이용해 키보드로부터 값을 입력받는 객체변수를 생성 후 사용

```java
Scanner scan01 = new Scanner(System.in);
inNum = scan01.netxInt();
```

- Scanner : 입력에 사용할 객체 변수를 생성할 때 사용하는 클래스 이름이다. 그대로 적어준다.
- scan01 : 객체 변수명이다. 사용자 임의로 적어준다.
- new : 객체 생성 예약어이다. 그대로 적어준다.
- Scanner( ) : 클래스의 이름이다. ( )를 붙여 그대로 적어준다.
- System.in : 표준 입력장치, 즉 키보드를 의미한다. 키보드로부터 값을 입력받는 객체 변수를 생성할 것이므로 그대로 적어준다.
- inNum : 입력받은 값을 저장할 변수이다. 이 변수는 미리 선언되어 있어야 한다.
- scan01.nextInt( )
  ▶ scan01 : 입력에 사용할 객체 변수 이름이다. 객체 변수 생성 시 사용한 객체 변수 이름과 동일해야 한다.
  ▶ nextInt( ) : 입력받은 값을 정수형으로 반환한다.
    • next( ) : 입력값을 문자열로 반환
    • nextLine( ) : 입력받은 라인 전체를 문자열로 반환
    • nextInt( ) : 입력값을 정수형으로 반환
    • nextFloat( ) : 입력값을 실수형으로 반환

```java
System.out.printf(서식 문자열, 변수)
```

- System.out.printf( ) : System 클래스의 서브 클래스인 out 클래스의 메소드 printf( )를 사용해서 출력한다는 의미이다.
printf( ) 메소드는 C언어의 printf( ) 함수와 사용법이 동일하다.

![image](https://user-images.githubusercontent.com/81230679/135223072-cd1a1a04-e6a5-433f-827a-bb9fdfdbe814.png)

## 연산자 우선순위

![image](https://user-images.githubusercontent.com/81230679/135225459-d5275a1c-d0a9-4017-9c18-e74a93be4378.png)

![image](https://user-images.githubusercontent.com/81230679/135228259-65a19c9e-5493-4fb5-8f80-5d2119ae26a4.png)


## switch-case
- case문의 레이블에는 한 개의 상수만 지정할 수 있으며, int, char, enum형의 상수만 가능하다.
- case문의 레이블에는 변수를 지정할 수 없다.
- break문은 생략이 가능하지만 break문이 생략되면 수식과 레이블이 일치할 때 실행할 문장부터 break문 또는 switch 문이 종료될 때까지 모든 문장이 실행된다.

## Java에서의 배열과 문자열
### Java에서의 배열 처리
- Java에서는 향상된 for문을 사용할 수 있는데, 향상된 for문은 객체를 대상으로만 가능하다.
- Java에서는 배열을 객체로 취급하며, 배열을 이용하여 작업할 때 필요할 만한 내용은 이미 API로 만들어 두었기 때문에잘 골라서 사용하면 된다.

```java
public class Example {
  public static void main(String[ ] args) {
    int[ ] a = {90,100,80,70,60,50,30};
    int hap = 0;
    float avg;
    for (int i : a)
    // 향상된 반복문. a배열의 요소 수만큼 for문 반복 수행
    // • int i : a 배열의 각 요소가 일시적으로 저장될 변수를 선언. a 배열과 형이 같아야 한다.
    // • a : 배열의 이름을 입력. a 배열이 7개의 요소를 가지므로 각 요소를 i에 저장하면서 7번 수행
    hap = hap + i;
    avg = (float)hap / a.length;
    System.out.printf("%d, %.2f", hap, avg);
  }
}
```

### Java에서의 문자열
- Java에서는 문자열을 처리할 수 있도록 클래스를 제공하므로 그에 따른 속성과 메소드도 당연히 지원하는데 여기서는 문제 풀이에 꼭 필요한 속성과 메소드만 학습한다.

```java
public class Example {
  public static void main(String[ ] args){
    String str = "Information!";
    int n = str.length( );
    char[ ] st = new char [n];
    n--;
    for (int k = n; k >= 0; k--) {
      st[n-k] = str.charAt(k);
      //charAt() 메소드는 해당 문자열에서 인수에 해당하는 위치의 문자열을 반환한다.
    }
    for (char k : st) {
      System.out.printf("%c", k);
    }
  }
}
```

## 포인터
### 포인터와 변수
- 포인터는 변수의 주소
- c언어에서는 주소를 제어할 수 있는 기능을 제공하며 변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라 함
- 포인터 변수 선언 시 자료형을 먼저 쓰고 변수명 앞에 간접 연산자 `*`사용( ex : `int *a;` )
- 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지연산자 `&`사용( ex : `a = &b;` )
- 실행문에서 포인터 변수에 간접 연산자 `*`를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말함( ex : `c = *a;` )

### 포인터와 배열
- 배열을 포인터 변수에 저장 후 포인터를 이용해 배열의 요소에 접근
- 배열 위치를 나타내는 첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같음

```c
int a[5], *b
b = a
// 배열의 대표명을 적었으므로 a 배열의 시작 주소인 a[0]의 주소를 b에 저장한다.
b = &a[0]
// a 배열의 첫 번째 요소인 a[0]의 주소(&)를 b에 저장한다.
```

![image](https://user-images.githubusercontent.com/81230679/135272124-d1e135b1-3e91-45ed-a9b7-667d0cb52e53.png)

## Java의 클래스와 메소드
- 클래스는 객체 생성을 위한 필드(속성)와 메소드(함수)를 정의하는 설계도로 Java는 아무리 작은 프로그램 이라도 클래스를 만들어 사용해야 함

```java
public class Example {
  static class AAclass {        // AAclass 클래스를 정의한다. 클래스 안에 클래스를 정의할 때는 static을 붙인다.
    int i;                               // •class : 클래스를 정의하는 명령어로, 꼭 써야하는 예약어이다.
    int j;
  }

  public static void main(String[ ] args) {
    AAclass myVal = new AAclass( );
    myVal.i = 10;
    myVal.j = 20;
    myVal = change(myVal);
    System.out.printf("i=%d, j=%d\n", myVal.i, myVal.j);
  }
  static AAclass change(AAclass myVal) {
    int temp;
    temp = myVal.i;
    myVal.i = myVal.j;
    myVal.j = temp;
    return myVal;
  }
}
```

## Python의 기초
### input() 함수
- Python의 표준 입력 함수로, 키보드로 입력받아 변수에 저장하는 함수
- 입력되는 값은 문자열로 취급되어 저장됨

```python
변수 = input(출력문자)
# 출력문자는 생략가능, 값을 입력하고 enter를 누르면 입력한 값이 '변수'에 저장
변수1, 변수2. ... = input(출력문자).split(분리문자)
# 화면에 '출력문자'가 표시되고 입력받은 값을 '분리문자'로 구분해 각각 변수1, 변수2, ... 에 저장, '분리문자'생략 시 공백
```

### print() 함수
- Python의 표준 출력 함수로, 값을 화면에 출력하는 함수

```python
print(출력값1, 출력값2, ..., sep = 분리분자, end = 종료문자)
# '출력값'에는 숫자, 문자, 문자열, 변수 등 다양한 값이나 식
# 'sep'는 여러값을 출력할 때 값과 값 사이 구분하는 문자, 생략할 경우 기본 값은 공백 한칸(' ')
# 'end'는 맨 마지막에 표시할 문자로 생략할 경우 기본 값은 줄 나눔
print(서식 문자열 % (출력값1, 출력값2, ...))
# C와 Java에서 사용했던 서식 문자열 동일 적용, 출력값이 한 개일 경우 출력값에 대한 괄호 생략 가능
```

### List
- C, Java에서는 여러 요소들을 한 개의 이름으로 처리할 때 배열을 사용하지만 Python에서는 리스트를 사용

```python
# 1차원 리스트 형식
리스트명 = [값1, 값2,...]
리스트명 - list([값1, 값2, ...])
# 2차원 리스트 형식
리스트명 = [
  [값1, 값2, 값3],
  [값4, 값5, 값6]]
  리스트A = [값1, 값2, 값3]
  리스트B = [값4, 값5, 값6]
  리스트명 = [리스트A, 리스트B]
  ```

### Range
  - 연속된 숫자를 생성하는 것(리스트, 반복문 등에서 많이 사용)

```python
range(최종값)
# 0에서 '최종값-1'까지 연속된 숫자 생성
range(초기값, 최종값)
# '초기값'에서 '최종값-1'까지 연속된 숫자를 생성
range(초기값, 중간값, 최종값)
# '초기값'에서 '최종값-1'까지 '증가값'만큼 증가하며 숫자 생성, '증가값'이 음수인 경우 '초기값'에서 '최종값+1'까지 '증가값'만큼 감소하며 숫자생성
```

### Slice
- 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라 반환하는 기능

```python
객체명[초기위치:최종위치]
객체명[초기위치:최종위치:증가값]
# slice는 일부 인수를 생략해 사용할 수 있음
객체명[:] 또는 객체명[::]     #객체의 모든 요소 반환
객체명[초기위치:]               #객체의 '초기위치'에서 마지막까지 반환
객체명[:최종위치]               #객체의 0번째 위치에서 '최종위치-1'까지의 요소 반환
객체명[::증가값]                 #객체의 0번째 위치에서 마지막 위치까지 '증가값'만큼 증가하며 해당 위치의 요소들을 반환
```

<img width="779" alt="스크린샷 2021-10-01 오후 4 05 46" src="https://user-images.githubusercontent.com/81230679/135579420-15316c0f-c645-4f1b-b767-48507c0f468b.png">

## 라이브러리

<img width="805" alt="스크린샷 2021-10-01 오후 4 21 07" src="https://user-images.githubusercontent.com/81230679/135581258-eb78ed2f-9220-44ba-8274-0a2a4b0c3962.png">

<img width="805" alt="스크린샷 2021-10-01 오후 4 22 32" src="https://user-images.githubusercontent.com/81230679/135581389-f21eeb36-1cc6-459d-ae7e-2871563031ab.png">

## 절차적 프로그래밍 언어
- C : 1972 미국 벨 연구소 데니스 리치. 시스템의 SW개발하기 편리해 시스템 프로그래밍 언어로 널리 사용. 포인터 제공. 고급과 저급특징. UNX의 일부가 C언어. 컴파일러 방식의. 이식성이 좋음
- ALGOL : 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어. PASCAL, C언어의 모체
- COBOL : 사무 처리용 언어. 영어 문장 형식으로 구성. 4개의 DIVISION으로 구성
- FORTRAN : 과학 기술 계산용 언어. 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 가능

## 객체지향 프로그래밍 언어
- Java : 분산 네트워크 환경에 적용 가능. 멀테스레드 기능 제공(멀티태스킹). OS, HW에 독립적이며 이식성 좋음. 캡슐화 가능, 재사용성 높음
- C++ : C언어에 객체지향 개념 적용. 모든 문제를 객체로 모델링해 표현
- Smalltalk : 1세대 객체지향 언어 중 하나로 순수한 객체지향 프로그래밍 언어. 최초로 GUI제공

### 객체지향 프로그래밍 언어의 구성 요소
- 객체(Object)
  - 데이터(속성)와 이를 처리하기 위한 연산(메소드)을 결합시킨 실체
  - 속성 : 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의하는 것으로서 성질, 분류, 식별, 수량 또는 현재 상태등을 표현
  - 메소드 : 객체가 메시지를 받아 실행해야 할 때 구체적인 연산을 정의하는 것, 객체의 상태를 참조하거나 변경하는 수단이 됨
- 클래스
  - 두 개 이상의 유사한 객체들을 묶어 하나의 공통된 특성을 표현하는 요소. 공통된 특성과 행위를 갖는 객체의 집합
  - 데이터를 추상화하는 단위
- 메시지
  - 객체들 간 상호작용을 하는데 사용되는 수단으로 객체의 메소드를 일으키는 외부의 요구사항

### 객체지향 프로그래밍 언어의 특징

<img width="804" alt="스크린샷 2021-10-01 오후 4 37 08" src="https://user-images.githubusercontent.com/81230679/135583128-9f3ed275-08cf-47c2-9e70-83e821677894.png">

## 스크립트 언어
- HTML 문서 안에 직접 프로그래밍 언어를 삽입해 사용하는 것, 기계어로 컴파일 되지 않고 별도의 번역기가 소스를 분석해 동작하게 하는 언어

### 서버용 스크립트 언어
- 서버에서 해석돼 실행된 후 결과만 클라이언트로 보내는 스크립트 언어
- ASP, JSP, PHP, PYTHON, PERL, RUBY

### 클라이언트용 스크립트 언어
- 클라이언트 웹 브라우저에서 해석돼 실행되는 스크립트 언어
- JS, VB 스크립트 등

### 스크립트 언어의 종류
- 자바 스크립트 : 넷스케이프의 브렌던 아이크가 개발한 언어로 웹 페이지의 동작을 제어, 변수 선언이 필요 없음
- ASP : 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 MS에서 제작했으며 windows 계열에서만 수행 가능한 프로그래밍 언어
- JSP : 자바로 만들어진 스크립트 언어로 다양한 os에서 사용 가능
- PHP : 서버용 스크립트 언어로 리눅스. 유닉스, 윈도우 os에서 사용 가능, c, java와 문법이 유사
- 파이썬 : 객체지향 기능을 지원하는 대화형 인터프리터 언어로 플랫폼에 독립적이고 문법이 간단해 배우기 쉬움

## 선언형 언어
### 함수형 언어
- 수학적 함수를 조합해 문제해결. 알려진 값을 함수에 적용하는 것을 기반으로 함(LISP)

### 논리형 언어
- 기호 논리학에 기반을 둔 언어, 논리 문장을 이용해 계산 수행(PROLOG)

<img width="799" alt="스크린샷 2021-10-01 오후 5 19 43" src="https://user-images.githubusercontent.com/81230679/135588446-d57f6ecc-f930-4cb6-92b1-4beef5c5f37b.png">

<hr>

# 요구사항 확인
### 현행 시스템 파악 절차
- 시스템 구성 파악 : 조직의 주요 업무를 담당하는 기간 업무와 이를 지원하는 지원 업무로 구분해 기술
- 시스템 기능 파악 : 단위 업무 시스템이 현재 제공하는 기능들을 주요기능과 하부기능, 세부기능으로 구분해 계층형으로 표시
- 시스템 인터페이스 파악 : 단위 업무 시스템 간 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등 명시
- 아키텍쳐 구성 파악 : 기간 업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성
- SW 구성 파악 : 설치되어 있는 SW의 제품명, 용도, 라이센스 적용 방식, 라이센스 수 등 명시
- HW 구성 파악 : 서버의 주요 사양과 수량, 이중화의 적용 여부 명시
- 네트워크 구성 파악 : 업무 시스템들의 네트워크 구성을 파악할 수 있도록 서버의 위치, 서버간 네트워크 연결 방식을 네트워크 구성도로 작성

### 개발 기술 환경
> 개발하고자 하는 SW와 관련된 OS, DB관리 시스템, 미들웨어 등 선정 시 고려사항 기술, 오픈소스 사용 시 주의사항 제시
- OS : 시스템의 자원관리, 사용환경 제공. 가용성, 성능, 기술 지원, 주변 기기, 구축 비용 등 고려
- DB 관리 시스템 : 요구에 따른 정보생성, DB관리. 가용성, 성능, 기술지원, 상호 호환성, 구축 비용 등 고려
- WAS : 동적인 콘텐츠 처리를 위한 미들웨아. 가용성, 성능, 기술지원, 구축비용 등 고려
- 오픈소스 : 라이센스 종류, 사용자 수, 기술의 지속 가능성 등 고려

### 요구사항 유형
- 기능 : 시스템이 갖춰야할 필수적인 기능
- 비기능 : 필수 기능 외 품질이나 제약사항 관련
- 사용자 : 사용자 관점) 시스템이 제공해야 할 요구사항
- 시스템 : 개발자 관점) 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항

### 요구사항 개발 프로세스
- 도출 : 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스 기법 이용
- 분석 : 불명확, 모호한 부분 발견 및 필터링. 비용과 일정에 대한 제약 설정, 타당성 조사
  - 요구사항 분류 : 명확한 확인을 위한 요구사항 분류
  - 개념 모델링 : 쉬운 이해를 위해 상황 단순화 및 개념적으로 표현. 유스케이스 다이어그램, 데이터 흐름 모델, 상태 모델, 목표기반 모델, 사용자 인터액션, 객체 모델, 데이터 모델 등
  - 요구사항 할당 : 요구사항 만족을 위한 구성 요소 식별
  - 요구사항 협상 : 요구사항 충돌 시 해결
  - 정형 분석 : 정형화된 언어를 이용해 요구사항을 수학적 기호로 표현
- 명세 : 체계적 분석 후 승인 가능하도록 문서화
- 확인 : 명세서의 정확성 완전성 검토
  - 요구사항 검토 : 문서화된 요구사항 확인
  - 프로토타이핑 : 초기 도출된 요구사항을 토대로 프로토타입 제작 후 지속적인 업데이트
  - 모델 검증 : 분석단계에서 개발된 모델의 요구사항 충족여부 검증
  - 인수 테스트 : 실제 환경에서 요구사항들이 모두 충족되느니 사용자 입장에서 확인

#### 자료 흐름도(Data Flow Diagram)
> 요구사항 분석에서 자료의 흐름 및 변환과정과 기능을 도형 중심으로 기술하는 방법
- 프로세스 : 자료를 변환시키는 시스템의 한 부분. 처리, 기능, 변환, 버블 이라고 하며 원, 둥근 사각형으로 표시하며 프로세스 이름 기입
- 자료 흐름 ; 자료의 이동, 연관 관게 표시. 화살표 위에 자료의 이름 기입
- 자료 저장소 : 시스템에서의 자료 저장소 나타냄. 도형 안에서 자료 저장소 이름 기입
- 단말 : 시스템과 교신하는 외부 개체. 도형 안에 이름 기입

### UML(Unified Modeling Language)
> 시스템 개발 과정(분석, 설계, 구현)에서 시스템 개발자와 고객 또는 개발자 상호 간 의사소통이 원할하게 이루어 지도록 표준화한 대표적인 객체지향 모델링 언어로 아래 3가지로 구성
- 사물 : 관계가 형성될 수 있는 대상들
  - 구조사물 : 시스템의 개념적, 물리적 요소표현
  - 행동사물 : 시공간에 따른 요소들의 행위 표현
  - 그룹사물 : 요소들을 그룹으로 묶어 표현
  - 주해사물 : 부가설명이나 제약조건 표현
- 관계 : 사물과 사물 사이의 연관성을 표현하는 것
  - 연관, 집합, 포함(포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 집합의 특수한 형태), 일반화, 의존(필요에 의해 짧은 시간만 연관), 실체화
- 다이어그램 : 사물과 관계를 도형으로 표현한 것
  - 정적 모델링 : 구조적 다이어그램 사용
  - 동적 모델링 : 행위 다이어그램 사용

#### 구조적 다이어그램
##### 클래스 다이어그램 : 클래스와 클래스가 가지는 속성, ㅋ르래스 사이의 관계 표현(정적 모델링의 대표)
- 클래스 : 각 개체들이 갖는 속성과 동작표현. 이름/속성(클래스의 상태나 정보 표현)/동작(함수)
- 제약조건
- 관계 : 클래스 간 연관성 표현
##### 객체 다이어그램 : 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
##### 컴포넌트 다이어그램 : 컴포넌트 간 관계, 인터페이스 표현
##### 배치 다이어그램 : 물리적 요소들의 위치 표현(결과물, 프로세스, 컴포넌트 등)
##### 복합체 구조 다이어그램 : 복합 구조를 갖는 경우 내부 구조 표현
##### 패키지 다이어그램 : 유스케이스나 클래스등의 모델 요소들을 그룹화한 패키지들의 관계 표현

#### 행위 다이어그램
> 행위 다이어그램에는 동적 모델링인 시퀀스 다이어그램, 커뮤니케이션 다이어그램, 상태 다이어그램, 기능 모델링인 유스케이스(Use Case) 다이어 그램, 활동(Activity) 다이어그램 등이 있다.

##### 시퀀스 다이어그램
- 시스템,객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호 작용하는 과정 표현
- 액터 : 시스템으로부터 서비스를 요청하는 외부요소(사람 or 외부 시스템)
- 객체 : 메시지를 주고받는 주체로 `;`을 기준으로 앞-객체명, 뒤-클래스명 기술
- 라이프라인 : 객체가 메모리에 존재하는 기간(객체 아래 점선 그어 표현)
- 활성 상자 : 객체가 메시지를 주고받으며 구동되고 있음을 라이프라인 상에 겹쳐 직사각형 형태로 표현
- 메시지 : 객체 간 주고받음
- 객체 소멸 : 라이프라인 상 소멸 표시를 만나면 해당 객체는 더 이상 메모리에 존재하지 않음을 의미
- 프레임 : 다이어그램의 전체 또는 일부를 묶어 표현

##### 커뮤니케이션 다이어그램
- 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하나, 객체들 간 연관까지 표현
- 액터, 객체
- 링크 : 객체들 간 관계 표현, 액터와 객체, 객체 간 실선으로 표현

##### 상태 다이어그램
- 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는 지 표현
- 상태 : 객체의 상태를 둥근 사각형 안에 기술. **●**-시작상태, **⊙**-종료상태
- 이벤트 : 조건, 외부신호, 시간 등 상태에 변화를 주는 현상
- 상태 전환 : 상태 사이의 흐름, 변화 화살표로 표현
- 프레임 : 상태 다이어그램의 범위 표현

##### 유스케이스 다이어그램
- 사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현
- 시스템 범위 : 내부/외부 구분을 위해 시스템 내부의 유스케에스들을 사각형으로 묶어 시스템의 범위 표현
- 액터 : 시스템과 상호작용 하는 모든 외부 요소
- 유스케이스 : 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능
- 관계 : 액터와 유스케이스, 유스케이스와 유스케이스. 포함 관계, 확정 관계, 일반화 관계

##### 활동 다이어그램
- 자료흐름도와 유사, 사용자 관점ㅇ에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현
- 액티비티 : 액션(더 이상 분해할 수 없는 단일 작업)으로 분리될 수 있는 작업
- 노드 : 시작 노드, 종료 노드, 조건(판단) 노드 : 조건에 따라 제어의 흐름 분리, 포그(Fork)노드 : 액티비티 흐름이 분리되어 수행됨, 조인(Join)노드 : 분리되어 수행되던 앧티비티 흐름이 다시 합쳐짐
- 스윔레인 : 액티비티 수행을 담당하는 주체를 구문

# 데이터 입출력 구현
> 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화해 체계적으로 표현한 개념적 모형
## 데이터 모델
### 구성 요소
  - 개체 : DB에 표현하려는 것, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
  - 속성 : 데이터의 가장 작은 논리적 단위. 파일 구조상 데이터 항목 또는 데이터 필드
  - 관계 : 개체 간 관계, 속성 간 논리적인 연결

### 종류
#### 개념적 데이터 모델
  : 현실 세계에 대한 인가의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
#### 논리적 데이터 모델
  : 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리하도록 컴퓨터 세계의 환경에 맞춰 변환하는 과정
#### 물리적 데이터 모델
  : 실제 컴퓨터에 데이터가 저장되는 방법을 정의하는 물리 DB설계 과정

#### 데이터 모델에 표시할 요소
- 구조 : 논리적으로 표현된 개체 타입들 간 관계로 데이터 구조 및 정적 성질 표현
- 연산 : DB에 저장된 실제 데이터를 처리하는 작업에 대한 명세. DB를 조작하는 기본 도구
- 제약 조건 : 저장될 수 있는 실제 데이터의 논리적인 제약 조건

## 이상(Anomaly)
- 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복발생 및 이로 인한 테이블 조작 시 문제 발생
### 이상의 종류
- 삽입 이상 : 테이블에 데이터를 삽입 시 원하지 않은 값들로 인해 삽입 불가능
- 삭제 이상 : 테이블 내 한 튜플 삭제 시 상관없는 값들도 함께 삭제(연쇄 삭제) 발생
- 갱신 이상 : 테이블 내 튜플에 있는 속성값 갱신 시 일부 튜플의 정보만 갱신되어 정보에 불일치성 발생

### 함수적 종속
> 어떤 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라 할 때 속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을때 Y는 X에 함수적 종속 또는 X가 Y를 함수적으로 결정한다고 하고, X → Y로 표기한다. X → Y의 관계를 갖는 속성 X와 Y에서 X를 결정자 (Determinant)라 하고, Y를 종속자(Dependent)라고 한다.

- 완전 함수적 종속 : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 어떠한 진부분 집합 Z(즉, Z ⊂ X)에도 함수적 종속이 아닐 때 속성 Y는 속성 집합 X에 완전 함수적 종속이라고 함
- 부분 함수적 종속 : 부분 함수적 종속 : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 임의의 진부분 집합에 대해 함수적 종속일 때, 속성 Y는 속성 집합 X에 부분 함수적 종속이라고 함

### 정규화(Normalization)
> 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용해 테이블을 무손실 분해하는 과정

- 정규화 과정

![image](https://user-images.githubusercontent.com/81230679/135783528-5409a403-327c-493a-944d-c76258cf0c32.png)

※ 이행적 함수족 종속 : A → B이고 B → C일 때 A → C 를 만족하는 관계를 이행적 함수적 종속이라고 함

### 반정규화(Denormalization)
> 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정. 의도적으로 정규화 원칙을 위배하는 행위

- 테이블 통합 : 두 개의 테이블이 Join되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움될 경우 수행
- 테이블 분할
  - 수평 분할 : 레코드를 기준으로 테이블을 분할하는 것. 레코드별 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블 분할
  - 수직 분할 : 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블 분할
- 중복 테이블 추가 : 여러 테이블에서 데이터를 추출해 사용하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가해 효율성 향상
  - 집계 테이블의 추가, 진행 테이블의 추가, 특정 부분만을 포함하는 테이블의 추가 등의 방법 사용
- 중복 속성 추가 : Join해서 데이터를 처리할 때 테이터 조회 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가

### 논리 데이터 모델의 물리 데이터 모델로 변환
- 엔티티를 테이블로 변환 : 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환
- 슈퍼타입 기준 테이블 변환 : 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 변환
- 서브타입 기준 테이블 변환 : 슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 변환
- 개별타입 기준 테이블 변환 : 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환
- 속성을 컬럼으로 변환 : 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환
- 관계를 외래키로 변환 : 논리 데이터 모델에서 정의된 관계는 기본키와 이를 참조하는 외래키로 변환

## 인덱스
> 데이터 레코드를 빠르게 접근하기 위해 `키값`,`포인터` 쌍으로 구성되는 데이터 구조. 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식의 클러스터드 인덱스와 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식인 넌클러스터드 인덱스가 있음

- 트리 기반 인덱스 : 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것, 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용
- 비트맵 인덱스 : 인덱스 컬럼의 데이터를 Bit값인 0,1로 변환해 인덱스 키로 사용하는 방법
- 함수 기반 인덱스 : 컬럼의 값 대신 특정 함수나 수식을 적용해 산출된 값을 사용. B+ 트리 인덱스 또는 비트맵 인덱스를 생성해 사용
- 비트맵 조인 인덱스 : 다수의 조인된 객체로 구성된 인덱스. 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다름
- 도메인 인덱스 : 개발자가 필요한 인덱스를 직접 만들어 사용하는 것. 확장형 인덱스 라고도 함

## 뷰(View)
> 접근이 허용된 자료만 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블. 저장 장치 내에 물리적으로 존재하지 않지만, 사용자에게 있는 것처럼 간주됨. `CREATE`문으로 정의, `DROP`문으로 제거. 데이터의 논리적 독립성을 제공

## 트랜잭션(Transaction)
> DB의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위. 한꺼번에 모두 수행되어야 할 일련의 연산들

### 트랜잭션 특징
- 원자성 : 트랜잭션의 연산은 DB에 모두 반영되도록 완료 or 전혀 반영되지 않도록 복구 되어야함
- 일관성 : 실행을 완료하면 언제나 일관성 있는 DB상태로 변환
- 독립성 : 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 서로의 연산에 끼어들 수 없음
- 지속성 : 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

## 클러스터
> 데이터 액세스 효율 향상을 위해 동일한 성격의 데이터를 동일한 데이터 블록에 물리적으로 저장
- 클러스터링 키로 지정된 컬럼 값의 순서대로 저장되고 여러 개의 테이블이 하나의 클러스터에 저장됨
- 클러스터링 된 테이블은 데이터 조회 속도는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하시킴
- 처리 범위가 넓은 경우 단일 테이블 클러스터링, 조인이 많이 발생하는 경우 다중 테이블 클러스터링 사용

## 파티션
> 대용량의 테이블이나 인덱스를 작은 논리적 단위로 나누는 것

- 범위 분할 : 지정한 열의 값을 기준으로 분할
- 해시 분할 : 해시 함수를 적용한 결과 값에 따라 데이터를 분할
- 조합 분할 : 범위 분할로 분할한 다음 해시 함수를 적용해 다시 분할
- 인덱스 파티션 : 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것

### 데이터 베이스 용량 설계
- 테이블에 저장할 데이터양, 인덱스, 클러스터 등이 차지하는 공간 등을 예측,반영 해야 함
- DB용량을 정확히 산정해 디스크의 저장 공간을 효과적으로 사용, 확장성 및 가용성을 높임
#### 데이터 접근성을 향상시키는 설계 방법
- 테이블의 테이블스페이스와 인덱스의 테이블스페이스를 분리해 구성
- 테이블스헤이스와 임시 테이블스페이스를 분리해 구성
- 테이블을 마스터 테이블과 트랜잭션 테이블로 분류

# 통합구현
> 사용자의 요구사항에 맞춰 송.수신 모듈과 중계모듈 간 연계를 구현하는 것. 일반적인 통합 구현은 송.수신 시스템과 모듈, 중계 시스템, 연계 데이터, 네트워크로 구성

- 송신 시스템과 모듈 : 데이터를 생성 및 변환해 전송, 송신 모듈과 모니터링 기능으로 구분. 모니터링 기능은 전송 데이터의 생성~송신까지의 과정과 송신 상태 등 확인
- 수신 시스템과 모듈 : 수신 받은 데이터를 정제 및 변환, 수신 모듈과 모니터링 기능으로 구분. 수신 데이터를 정제, 애플리케이션이나 DB 테이블에 적합한 데이터로 변환
- 중계 시스템 : 내.외부 시스템 간 또는 내부 시스템 간 연계 시 사용되는 아키텍쳐
- 연계 데이터 : 송.수신 되는 데이터. 속성, 길이, 타입 등이 포함
- 네트워크 : 송.수신 시스템, 중계 시스템을 연결해주는 통신망

## 연계 요구사항 분석
> 통합 구현을 위해 사용자 요구사항을 분석하고 연계 데이터를 식별 및 표준화 해 연계 데이터를 정의하는 것

### 연계 요구사항 분석 절차

1. 시스템 구성도, 응용 애플리케이션 구성 등을 통해 송.수신 시스템의 H/W, S/W구성, 네트워크 현황 확인
  - 시스템 구성도 : 송.수신 시스템의 H/W, S/W, 네트워크 구성 등을 정의한 문서
  - 응용 애플리케이션 구성 : 메뉴 구조, 화면 설계, 데이터의 발생 시점, 발생 유형, 발생 주기 등을 정의한 문서
2. 송.수신 시스템과 연결할 데이터와 관련된 테이블 정의서, 코드 정의서 등의 문서 확인
  - 테이블 정의서 : 테이블에서 관리되는 컬럼들의 특징, 인덱스, 업무 규칙 등을 정의한 문서
  - 코드 정의서 : DB에서 코드성 속성을 정의한 문서
3. 확인된 시스템의 구성과 데이터 현황 정보 등을 기반으로 체크리스트 작성
4. 시스템 구성도, 응용 애플리케이션 구성, 테입르 정의서, 코드 정의서, 체크리스트 등을 사용자, 시스템 관리자 등과 공유 및 인터뷰, 설문조사 실시
5. 인터뷰나 설문조사를 통해 확인된 결과를 기반으로 요구사항의 ID, 이름, 유형, 설명, 해결 방안 등이 포함된 연계 요구사항 분석서 작성

## 연계 데이터 식별 및 표준화
> 연계 데이터를 구성하기 위해 연계 데이터를 식별하고 식별된 연계 데이터를 표준화 한 후 이를 기반으로 연계(인터페이스) 정의서 작성

### 연계 데이터 식별 및 효준화 절차
1. 연계 범위 및 항목 정의 : 데이터 타입, 길이, 코드화 여부 등 시스템 간 연계할 정보 상세화
2. 연계 코드 변환 및 매핑 : 정보로 전환 OR 검색 조건으로 활용하기 위해 연계 정보 중 코드로 관리되어야 할 항목 변환
3. 연계 데이터 식별자와 변경 구분 추가 : 수신 시스템의 연계 정보에 송신 시스템의 식별자, 추가, 수정, 삭제 중 어떤 조작을 수행하는지 식별해주는 구분 정보 추가, 연계 데이터의 확인 및 모니터링을 위해 인터페이스 테이블 또는 파일에 관리 정보 추가
4. 연계 데이터 표현 방법 정의 : 연계 대상 범위 및 항목과 코드 변환 및 매핑 방식을 정의한 후에는 연계 데이터 구성
5. 연계 정의서 및 명세서 작성
  - 연계 정의서는 송.수신 시스템에서 연계할 항목과 연계 데이터의 타입, 길이 등을 구성하고 형식을 정의한 결과를 기반으로 작성
  - 연계 정의서에는 송.수신 시스템의 시스템명과 인터페이스ID, 인터페이스 방식 및 주기 등 송.수신 시스템 간 인터페이스 현황을 기재
  - 연계 명세서는 연계 정의서에 작성한 인터페이스 ID별로 인터페이스 주기 및 방식, DB및 파일 형식, 송.수신 시스템의 타입, 길이, 식별자, 코드화 여부 등 세부사항 작성

### 연계 메커니즘 
- 데이터의 생성 및 전송을 담당하는 송신 체계와 데이터 수신 및 운영 DB반영을 담당하는 수신 체계로 구성
- 송신 시스템은 운영 DB로부터 인터페이스 테이블이나 파일(xml, text, csv등) 형식으로 연계 데이터를 생성해 송신
- 수신 시스템은 송신 시스템으로부터 전송된 데이터를 받아 수신 시스템에 맞는 데이터로 변환 후 운영 DB에 반영
- 송.수신 시스템 사이에는 데이터의 송.수신과 송.수신 시스템 현황을 모니터링 하는 중계 시스템을 설치할 수 있음
- 송.수신 시스템과 중계 시스템은 제각기 역하이 중복되지 않도록 아키텍쳐 설계 후 인터페이스 테스트와 통합 테스트를통해 기능 검증
- 연계 메커니즘의 연계 방식에는 직접 연계 방식과 간접 연계 방식이 있음

#### 연계 메커니즘의 직접 연계 방식
> 중간 매개체 없이 송.수신 시스템이 직접 연계하는 방식

![image](https://user-images.githubusercontent.com/81230679/135844613-488d1b41-8c2f-4501-b616-dd372e19df00.png)

- DB Link : DB에서 제공하는 DB Link객체를 이용하는 방식
- API : 데이터를 송신 시스템의 DB에서 읽어와 제공하는 애플리케이션 프로그래밍 인터페이스
  - API : 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 응용프로그램 개발 시 이용할 수 있도록 정의해 놓은 인터페이스
  - Open API : API기능을 누구나 무료로 사용해 프로그램을 개발하거나 새로운 API를 추가할 수 있도록 공개된 API
- DB Connection : 수신 시스템의 WAS에서 송신 시스템의 DB로 연결해주는 방식
- JDBC : Java에서 DB에 접근해 데이터를 삽입, 삭제, 수정, 조회할 수 있도록 Java, DB를 연결해주는 방식

#### 연게 메커니즘의 간접 연계 방식
> 송.수신 시스템 사이에 중간 매개체를 두어 연계하는 방식

![image](https://user-images.githubusercontent.com/81230679/135845294-34f5b03d-e986-4398-903f-00a3eb9840de.png)

- 연계 솔루션 : EAI(송.수신 처리 및 진행 현황 모니터링 및 통제 시스템)서버와 송.수신 시스템에 설치되는 클라이언트를 이용하는 방식
- ESB : 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 방식
- Socket : 서버는 통신을 위한 소켓을 생성해 포트할당, 클라이언트의 통신 요청 시 클라이언트와 연결해 통신하는 네트워크 기술
- Web Service : 웹 서비스에서 WSDL과 UDDI, SOAP 프로토콜을 이용해 연계하는 방식

#### 연계 메커니즘의 구성

![image](https://user-images.githubusercontent.com/81230679/135845685-44df49ad-eaee-4165-8d8b-fbd454a834d7.png)

#### 연계 메커니즘 구간별 장애 및 오류 모니터링 현황

<img width="477" alt="스크린샷 2021-10-05 오후 7 05 18" src="https://user-images.githubusercontent.com/81230679/136003147-f053d04a-8585-4905-ba07-6cfb8a3534d5.png">

#### 연계 데이터 보안
> 송신시스템에서 수신 시스템으로 전송되는 연계 데이터는 보안에 취약할 수 있으므로 데이터의 중요성을 고려해 보안을 적용해야 함. 일반적으로 연계 데이터의 보안은 전송 구간에서의 암.복호화로 구현

- 전송 구간 보안 : 전송되는 데이터나 패킷을 쉽게 가로챌 수 없도록 암호화 기능이 포함된 프로토콜 사용, 내용을 확인할 수 없게 데이터나 패킷 암호화
- 데이터 보안 : 송신 시스템에서 연계 데이터 추출 시 수신 시스템에서 데이터 운영 DB에 반영 시 데이터를 암.복호화, 데이터 보안을 위해 암.복호화 적용 대상 선정, 암호화 알고리즘, 암.복호화 적용을 위한 환경 설정을 설계 및 구현(암.복호화 적용 대상은 연계 데이터의 중요도에 따라 선정)

#### 연계 모듈의 구현 환경
> 연계 메커니즘에 다라 구현된 연계 시스템 환경 및 모듈 구현 환경. 트리거 또는 프로그래밍 언어를 이용한 EAI, ESB 방식과, 배치 프로그램 및 인터페이스 파일을 이용한 웹 서비스 방식으로 구분

- EAI : 기업 내 애플리케이션 및 플랫폼 간 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
  - Point-to-Point : 가장 기본적인 애플리케이션 통합 방식으로, 애플리케이션을 1 : 1로 연결
  - Hub & Spoke : 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
  - Message Bus(ESB 방식) : 애플리케이션 사이 에 미들웨어를 두어 처리하는 방식
  - Bus Hybrid : Hub & Spoke와 Message Bus 의혼합방식
- ESB : 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션. EAI와 유사하나 애플리케이션 보다는 서비스 중심의 통합 지향
- 웹 서비스 : 네트워크의 정보를 표준화된 서비스 형태로 만들어 공유하는 기술. 서비스 지향 아키텍쳐 (SOA)개념을 실현하는 대표적인 기술
  - SOAP(Simple Object Access Protocol) : HTTP, HTTPS, SMTP 등을 화용해 XML기반의 메시지를 네트워크 상에서 교환하는 프로토콜
  - UDD(Universial Description, Discovery and Intergration) : WSDL을 등록해 서비스와 서비스 제공자를 검색하고 접근하는데 사용됨
  - WSDL(Web Services Description Language) : 웹 서비스명, 서비스 제공 위치, 프로토콜 등 웹 서비스에 대한 상세 정보를 XML형식으로 구현

#### 연계 테스트
> 구축된 연계 시스템과 연계 시스템의 구성 요소가 정상적으로 동작하는지 확인하는 활동

1. 연계 테스트 케이스 작성 : 
2. 연계 테스트 환경 구축 : 
3. 연계 테스트 수행 : 
4. 연계 테스트 수행 결과 검증 : 

### XML(eXtensible Markup Language)
> 웹브라우저 간 HTML문법이 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위해 개발된 다목적 마크업 언어. 유니코드 기반의 다국어 지원. 사용자 태그 정의 가능, 다른 사용자가 정의한 태그 사용 가능

```xml
 <!-- XML의 첫 문단 -->
<?xml version="버전" encoding="언어셋" standalone ="yes|no"?>
<!-- XML 요소(Element)의 구성 -->
<요소이름 속성1="속성값1" 속성 2="속성값2"... > 내용 </요소 이름>
```

### JSON(JavaScript Object Notation)
> 송석-값 쌍으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷. 비동기 처리에 사용되는 AJAX에서 XML을 대체해 사용

# 서버 프로그램 구현

## 개발환경 구축
### 하드웨어 환경
> 응용 소프트웨어 개발을 위해 개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것. 사용자와의 인터페이스 역할을 하는 클라이언트, 클라리언트와 통신해 서비스를 제공하는 서버로 구성.  서버는 사용 목적에 따라 웹 서버, 웹 애플리케이션 서버, DB서버, 파일 서버 등으로 나뉨.

- 웹 서버 : 클라이언트로부터 직접 요청을 받아 처리하는 서버, 저용량의 정적파일 제공
- 웹 애플리케이션 : 사용자에게 동적 서비스 제공을 위해 웹 서버로부터 요청을 받아 데이터 가공 작업 수행, 웹 서버와 DB 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할 수행
- DB 서버 : DB와 이를 관리하는 DBMS를 운영하는 서버
- 파일 서버 : DB에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장하는 서버

### 소프트웨어 환경
> 클라이언트와 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성. 시스템 소프트웨어는 OS, 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS등. 개발 소프트웨어는 요구사항 관리 도구, 설계/모델링 도구, 구현 도구, 빌드 도구, 테스트 도구, 형상 관리 도구 등.

- 요구사항 관리 도구 : 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 S/W
- 설계/모델링 도구 : UML(통합 모델링 언어)을 지원, 개발의 전 과정에서 설계 및 모델링을 도와주는 S/W
- 구현 도구 : 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어
- 빌드 도구 : 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 S/W
- 테스트 도구 : 코듈들이 요구사항에 적합하게 구현되었는지 테스트하는 S/W
- 형상 관리 도구 : 산출물들을 버전별로 관리해 품질 향상을 지원하는 S/W

### 모듈
> 모듈화 : 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 분해하는 것. 모듈 간 결합도는 최소화 응집도는 최대화가 목표


-  모듈화를 통해 분리된 시스템의 각 기능들로 서브루틴, 서스시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용됨
-  모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독림됨을 의미하는 것, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호 작용을 배제함으로써 이루어짐
-  독립성이 높은 모듈일수록 모듈을 수정하더라도 다른 모듈들에게는 거의 영향을 미치지 않으며, 오류가 발생해도 쉽게 발견하고 해결할 수 있음
-  모듈의 독립성은 결합도와 응집도에 의해 측정되며, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 함

#### 결합도(Coupling)
> 모듈 간 상호 의존하는 정도 또는 두 모듈 사이 연관 관계

- 다양한 결합으로 모듈구성 가능하나 결합도가 약할수록 품질이 높음
- 결합도가 강하면 시스템 구현 및 유지보수가 어려움


<img width="416" alt="스크린샷 2021-10-07 오후 12 21 11" src="https://user-images.githubusercontent.com/81230679/136315265-e1949015-7540-4381-b4d6-1b4177aa10b6.png">

#### 응집도
> 정보 은닉 개념의 확장. 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도. 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미

- 다양한 기준으로 모듈을 구성할 수 있으나 응집도가 강할수록 품질이 높음

<img width="407" alt="image" src="https://user-images.githubusercontent.com/81230679/136315508-fadf25af-0f8b-4c4f-8c2d-a7aedea2b31d.png">

<img width="404" alt="image" src="https://user-images.githubusercontent.com/81230679/136315574-e617e615-d90b-415d-ad23-29fda9abe688.png">

### Fan-In / Fan-Out
> 팬인 : 어떤 모듈을 제어(호출)하는 모듈의 수 / 팬아웃 : 어떤 모듈에 의해 제어(호출)되는 모듈의 수

- 팬인, 팬아웃 분석해 시스템의 복잡도 확인.
- 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있으나, 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트 필요

<img width="421" alt="image" src="https://user-images.githubusercontent.com/81230679/136315765-9e80369f-c7d6-49a3-a906-8df00888f580.png">

### 공통 모듈
> 여러 프로그램에서 공통적으로 사용할 수 있는 모듈. 자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능들이 공통모듈로 구성.

- 공통 모듈을 구현할 때는 다른 개발자들이 해당 기능을 명확히 이해할 수 있도록 명세기법 준수 해야 함
  - 정확성 : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성
  - 명확성 : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확히 작성
  - 완전성 : 시스템 구현을 위해 필요한 모든 것을 기술
  - 일관성 : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
  - 추적성 : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악하도록 작성

## 재사용
> 비용과 개발 시간 절약을 위해 이미 개발된 기능들 파악, 재구성해 새로운 시스템 또는 기능 개발에 사용하기 적합하도록 최적화 시키는 작업

- 재사용되는 대상은 외부 모듈과의 결합도는 낮고, 응집도는 높아야 함
- 재사용 규모에 따른 분류
  - 함수와 객체 : 클래스나 메소드 단위의 소스 코드를 재사용
  - 컴포넌트 : 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용
  - 애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용

### DBMS 접속
> 사용자가 데이터 사용을 위해 응용 시스템을 이용해 DBMS에 접근 하는 것

- 응용 시스템은 사용자로부터 매개 변수를 전달받아 SQL을 실행하고 DBMS로부터 전달받은 결과를 사용자에게 전달하는 매개체 역할을 수행
- 인터넷을 통해 구동되는 웹 응용 프로그램은 웹 응용 시스템을 통해 DBMS에 접근
- DBMS 접속 기술 : DBMS에 접근하기 위해 사용하는 API또는 API의 사용을 편리하게 도와주는 프레임워크
####  프레임워크
> 특정 기능을 수행하기 위해 필요한 클래스나 인터페이스 등을 모아둔 집합체

<img width="409" alt="image" src="https://user-images.githubusercontent.com/81230679/136320078-e1b0af7e-6b41-4e65-9a9f-1d39153594a7.png">

- JDBC : Java로 다양한 종류의 DB에 접속, SQL문 수행 시 사용되는 표준 API
- ODBC : DB에 접근하기 위한 표준 개방형 API, 개발 언어에 관계없이 사용할 수 있음
- MyBatis : JDBC 코드를 단순화해 사용할 수 있는 SQL Mapping기반 오픈 소스 프레임워크. SQL을 거의 그대로 사용할 수 있어 SQL친화적인 국내 환경에 적합해 많이 사용됨
  - 동적 SQL(Dynamic SQL) : 다양한 조건에 따라 SQL 구문을 동적으로 변경해 처리할 수 있는 SQL 처리 방식. 사용자로부터 SQL문의 일부 또는 전부를 입력받아 실행할 수 있으며, 정적 SQL에 비해 속도가 느리지만, 상 황에  따라  다양한  조건을  첨가하는  등  유연한  개발 이 가능
  - 정적 SQL :  SQL코드를 변수에 담지 않고 코드 사이에 직접 기술한 SQL문

### 서버개발
> 웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작해 웹 애플리케이션 서버에 탑재하는 것

- 웹 애플리케이션 서버에 구현된 서버 프로그램은 웹 서버로부터 받은 요청을 처리해 결과를 반환하는 역할 수행
- 서버 개발에 사용되는 프로그래밍 언어네느 Java, JS, Python, PHP, Ruby 등이 있음
- 객 프로그래밍 언어에는 해당 언어로 서버 프로그램을 개발할 수 있도록 지원하는 프레임워크가 있음

<img width="410" alt="image" src="https://user-images.githubusercontent.com/81230679/136319774-0e440d68-62b4-4f05-b2d4-d5c93da617ac.png">

### 서버 개발 과정
- 서버  개발은  DTO/VO,  SQL,  DAO,  Service, Controller를 각각 구현하는 과정을 통해 이루어짐.
- 구현 순서는 개발자가 임의 변경 가능
- 개발하려는 서버 프로그램의 목적, 개발 언어, 규모 등의 이유로 총합 or 세분화 가능
- 모든 과정에서 보안 약점이 발생하지 않도록 소프트웨어 개발 보안 가이드 참고

<img width="409" alt="스크린샷 2021-10-07 오후 1 25 20" src="https://user-images.githubusercontent.com/81230679/136320236-955e2daf-5186-42ea-b0ee-6940970ae2f0.png">

<img width="406" alt="image" src="https://user-images.githubusercontent.com/81230679/136320273-c70538dd-1d22-4f17-b66f-ec83d6dfcd49.png">

### 배치 프로그램(Batch Program)
> 사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것을 의미

- 배치 프로그램이 자동으로 수행되는 주기에 따라 정기 배치, 이벤트성 배치, On-Demand 배치로 구문
- 필수 요소 : 대용량 데이터, 자동화, 견고성, 안정성/신뢰성, 성능
- 배치 스케줄러 : 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구

<img width="407" alt="image" src="https://user-images.githubusercontent.com/81230679/136320448-813fae80-0f74-45ce-a55a-8ac2ce1161f7.png">

# 화면 설계

## 사용자 인터페이스
> 사용자와 시스템 간 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어

- CLI(Command Line Interface) : 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스
- GUI(Graphical User Interface) : 아이콘이나 메뉴를 마우스로 선택해 작업을 수행하는 그래픽 환경의 인터페이스
- NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스

### 사용자 인터페이스 기본 원칙
- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함
- 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함
- 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 함
- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화 해야 함

### 사용자 인터페이스 설계 지침
- 사용자 중심 : 사용자가 쉽게 이해하고 편리하게 사용할 수 있는 환경 제공, 실사용자에 대한 이해가 바탕이 되어야 함
- 일관성 : 버튼이나 조작 방법등을 일관성 있게 제공해 사용자가 쉽게 기억하고 습득할 수 있게 설계
- 단순성 : 조작 방법을 단순화시켜 인지적 부담을 감소
- 결과 예측 가능 : 작동시킬 기능만 보고도 결과를 미리 예측할 수 있게 설계
- 가시성 : 메인 화면에 주요 기능을 노출시켜 최대한 조작이 쉽도록 설계
- 표준화 : 기능 구조와 디자인을 표준화해 한 번 학습한 이 후에는 쉽게 사용할 수 있도록 설게
- 접근성 : 사용자의 연력, 성별, 인종 등 다양한 계층이 사용할 수 있도록 설계
- 명확성 : 사용자가 개념적으로 쉽게 인지할 수 있도록 설계
- 오류 발생 해결 : 오규라 발생하면 사용자가 쉽게 인지할 수 있도록 설계

### UI 설계 도구
- 와이어프레임 : 기획 단계의 초기에 제작, 페이지에 대한 개략적인 레이아웃이나 UI요소 등에 대한 뼈대 설계. 각 페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계
- 목업 : 디자인, 사용 방법 설명, 평가 등을 위해 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 모형. 시각적으로만 구성 요소를 배치하는 것(실제 구현X)
- 스토리보드 : 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 추가. 상단이나 우측에는 제목, 작성자, 좌측에는 UI화면, 우측에는 디스크립션 기입
- 프로토타입 : 와이어프레임이나 스토리보드에 인터랙션 적용해 실제 구현된 것 처럼 테스트가 가능한 동적인 모형. 사용성 테스트나 작업자 간 서비스 이해를 위해 작성하는 샘플
  - 페이퍼 프로토타입 : 아날로그적 방법, 스케치, 그림, 글 등을 이용해 손으로 직접 작성하는 방법
  - 디지털 프로토타입 : 파워포인트, 아크로뱃, 비지오, 옴니그래플 등과 같은 프로그램을 사용해 작성하는 방법
- 유스케이스 : 사용자 측면에서의 요구사항, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술. 사용자의 요구사항을 빠르게 파악함으로써 프로젝트 초기에 시스템의 기능적인요구를 결정하고 그 결과를 문서화

### UI 스타일 가이드 작성
> 개발자나 디자이너들이 UI를 작성할 때 기준이 되는 규칙들, 구동 환경, 레이아웃, 네비게이션 등을 정의

- 구동 환경 정의 : 컴퓨터 OS, 웹 브라우저, 모니터 해상도, 프레임 세트 등을 사용 환경에 적합하도록 규정하는 단계
- 레이아웃 정의 : 화면 구조를 정의하고 각 영역의 메뉴를 구성하는 단계. Top, Left, Contents, Footer Area가 있으며, 기본적으로 Top, Left, Contents영역으로 구성
  - Top : 필수 영역으로 시스템 전체 페이지에 동일하게 적용
  - Left : 선택 영역으로 시스템별 서브 페이지에 선택적으로 적용
  - Contents : 필수 영역으로 시스템의 전체 콘셉트를 나타내는 메인 이미지와 시스템별 필요한 콘텐츠를 표시
  - Footer : 선택 영역으로 회사 상황에 따라 표시 여부 결정
- 네비게이션 정의 : 메뉴타입을 선택해 적용하는 단계. 사용자가 원하는 정보를 빠르게 찾을 수 있도록 안내하는 것. 메뉴, 버튼, 링크 등으로 구성
- 기능 정의 : 시스템에 적용할 업무 과정에서 일어나는 모든 활동이나 필요한 데이터 간 관계 등을 논리적인 모델로 상세화 하는 단계
- 구성 요소 정의 : 화면에 표시할 그리드나 버튼 등을 정의하는 단계

## UI 요구사항 확인
> 새로 개발할 시스템에 적용할 UI 관련 요구사항을 조사해 작성하는 단계

<img width="454" alt="image" src="https://user-images.githubusercontent.com/81230679/136328035-24513235-23f0-4f3f-ade6-86c64db5ebba.png">

### UI 흐름 설계
> 업무의 진행 과정이나 수행 절차에 따른 흐름을 파악해 화면과 폼을 설계하는 단계

- 기능 작성 : 화면에 표현할 기능을 작성하는 단계
- 입력 요소 확인 : 화면에 표현되어야 할 기능을 확인한 후 화면에 입력할 요소를 확인하는 단계
- 유스케이스 설계 : UI 요구사항 기반으로 UI 유스케이스 설계 단계. 화면에 표현할 입력 요소들의 형태나 입력 방법, 배치 등을 고려해 설계
- 기능 및 양식 확인 : 분석한 기능을 토대로 텍스트 박스, 콤보 박스, 라디오 박스, 체크 박스 등을 확인하고 규칙 정의

### UI 상세 설계
> 실제 설계 및 구현을 위해 모든 화면에 대해 자세한 설계 진행하는 단계

<img width="445" alt="image" src="https://user-images.githubusercontent.com/81230679/136328492-f4f02b50-99fa-4d18-a364-5049b0c04a9b.png">

# 애플리케이션 테스트 관리

## 애플리케이션 테스트
> 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차. 개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인하고 소프트웨어가 기능을 정확히 수행하는지 검증

### 애플리케이션 테스트의 기본 원리
- 완벽한 테스트 불가능 : 애플리케이션 테스트는 소프트웨어의 잠재적인 결함을 줄일 수 있지만 결함이 없다고 증명할 수는 없음.
- 결함 집중 : 애플리케이션의 결함은 대부분 개발자의 특성이나 애플리케이션의 기능적 특징 때문에 특정 모듈에 집중되어 있으며, 애플리케이션의 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다고 하여 파레토 법칙을 적용하기도 함
- 살충제 패러독스 : 애플리케이션 테스트에서는 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 살충제 패러독스 현상이 발생하며 살충제 패러독스를 방지하기 위해 테스트 케이스를 지속적으로 보완 및 개선 해야 함
- 테스팅은 정황 의존 : 소프트웨어 특징, 테스트 환경, 테스터 역량 등 정황에 따라 테스트 결과가 달라질 수 있으므로 정황에 따라 테스트를 다르게 수행해야 함
- 오류-부재의 궤변 : 소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 ㅎ말할 수 없음을 의미

### 애플리케이션 테스트의 분류
- 프로그램 실행 여부에 따른 테스트
  - 정적 테스트 : 프로그램 실행하지 않고 명세서나 소스코드를 대상으로 분석
  - 동적 테스트 : 프로그램을 실행해 오류를 찾는 테스트. S/W 개발 모든 단계에서 테스트 수행 가능
- 테스트 기반에 따른 테스트
  - 명세 기반 테스트 : 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트
  - 구조 기반 테스트 : S/W 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트
  - 경험 기반 테스트 : 유사 S/W나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트
- 시각에 따른 테스트
  - 검증 테스트 : 개발자의 시각에서 제품의 생산 과정을 테스트하는 것으로, 제품이 명세서대로 완성 됐는지를 테스트함
  - 확인 테스트 : 사용자의 시각에서 생산된 제품의 결과를 테스트하는 것으로, 사용자가 요구한대로 제품이 완성됐는지, 제품이 정상적으로 동작하는지를 테스트함
- 목적에 따른 테스트
  - 회복 테스트 : 시스템에 여러가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지 확인
  - 안전 테스트 : 시스템에 설치된 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지 확인
  - 강도 테스트 : 시스템에 과도한 정보량이나 빈도 등을 부과해 과부하 시에도 S/W가 정상적으로 실행되는지 확인
  - 성능 테스트 : S/W의 실시간 성능이나 전체적인 효율성을 진단하는 테스트. 응답시간, 처리량 등을 테스트
  - 구조 테스트 : S/W 내부의 논리적인 경로, 소스코드의 복잡도 등을 평가하느 테스트
  - 회귀 테스트 : S/W의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
  - 병행 테스트 : 변경된 S/W와 기존 S/W에 동일한 데이터를 입력해 결과 비교하는 테스트

### 화이트박스 테스트
> 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트해 테스트 케이스를 설계하는 방법

- 원시코드의 문장을 한 번이상 실행함으로써 수행됨. 모듈 안의 작동을 직접 관찰할 수 있음

#### 화이트박스 테스트 종류
- 기초 경로 검사 : 테스트 케이스 설계자가 절차적으로 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법. 테스트 측정 결과는 실행 경로의 기초를 정의하는데 지츰으로 사용됨
- 제어 구조 검사
  - 조건검사 : 프로그램 모듈 내 논리적 조건을 테스트하는 테스트 케이스 설계 기법
  - 루프검사 : 프로그램의 반복 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
  - 데이터 흐름 검사 : 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법

#### 화이트박스 테스트 검증 기준
> 테스트 케이스들이 테스트에 얼마나 적정한지를 판단하는 기준.

- 문장 검증 기준, 분기 검증 기준, 조건 검증 기준, 분기/조건 기준 등이 있음

### 블랙박스 테스트
> S/W가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트. 기능 테스트라고도 함

- 사용자의 요구사항 명세를 보면서 테스트하는 것으로, 주로 구현된 기능을 테스트. S/W 인터페이스에서 실시되는 테스트

#### 블랙박스 테스트 종류
- 동치 분할 검사 : 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 기법
- 경계값 분석 : 입력 자료에만 치중한 동치 분할 기법을 보완하기 위한 기법으로, 입력 조건의 경계값을 테스트 케이스로 선정하여 검사함
- 원인 - 효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
- 오류 예측 검사 : 과거의 경험이나 확인자의 감각으로 테스트하는 기법
- 비교 검사 : 여러 버전의 프로글매에 동일한 테스트 자료를 제공해 동일한 결과가 출력되는지 테스트

### 개발 단게에 따른 애플리케이션 테스트
- 단위 테스트 : 코딩 직후 S/W설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것
  - 구조기반 테스트 : 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트 시행
  - 명세기반 테스트 : 목적 및 실행 코드 기반의 블랙박스 테스트 시행
- 통합 테스트 : 단위 테스트가 완료된 모듈들을 결합해 하나의 시스템으로 완성시키는 과정에서의 테스트 의미
  - 비점진적 통합 방식 : 단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트 하는 방법. 규모가 작은 S/W에서 유리하며 단시간 내에 테스트 가능
    - 빅뱅 통합 테스트 : 모듈 간 상호 인터페이스를 고려하지 않고 단위 테스트가 끝난 모듈을 한꺼번에 결합시켜 테스트 하는 방법
  - 점진적 통합 방식 : 모듈 단위로 단계적으로 통합하며 테스트하는 방법. 오류 수정이 용이, 인터페이스와 연관된 오류를 완전히 테스트할 가능성 높음
    - 하양식 통합 테스트 : 프로그 램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법
    - 상향식 통합 테스트 : 프로그 램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법
    - 혼합식 통합 테스트 : 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식으로, 샌드위치(Sandwich)식 통합 테스트 방법이라고도 함
  - 회귀 테스트 : 이미 테스트된 프로그램의 테스팅을 반복하는 것. 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인

- 시스템 테스트 : 개발된 S/W가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트
- 인수 테스트
  > 개발한 S/W가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트 하는 것

  - 알파 테스트 : 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법, 테스트는 통제된 환경에서 행해지며 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하며 기록
  - 베타 테스트 : 선정된 최종 사용자가 여러명의 사용자 앞에서 행하는 테스트 기법, 개발자에 의해 제어되지 않은 상태에서 테스트가 행해지며 발견된 오류와 사용상의 문제점을 기록하고 개발자에게 주기적으로 보고

### 애플리케이션 테스트 프로세스
> 개발된 S/W가 사용자의 요구대로 만들어졌는지, 결함은 없는지 등을 테스트하는 절차

![image](https://user-images.githubusercontent.com/81230679/136399539-cb1d9932-a2f2-4043-ada3-01e4a5665d19.png)


### 테스트 케이스
> 구현된 S/W가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서로 명세 기반 테스트의 설계 산출물에 해당

![image](https://user-images.githubusercontent.com/81230679/136402356-8b925439-8703-44ae-a338-772d31f7848a.png)

### 테스트 시나리오
> 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합으로, 테스트 케이스들을 적용하는 구체적인 절차를 명세한 문서이다.

- 테스트 시나리오에는 테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정되어 있다.
- 테스트 시나리오는 시스템별, 모듈별, 항목별 등과 같이 여러 개의 시나리오로 분리하여 작성해야 한다.
- 각각의 테스트 항목은 식별자 번호, 순서 번호, 테스트 데이터, 테스트 케이스, 예상 결과, 확인 등을 포함해서 작성해야 한다.
- 테스트 시나리오는 유스케이스(Use Case) 간 업무 흐름이 정상적인지를 테스트할 수 있도록 작성해야 한다.

### 테스트 오라클
> 테스트 결과가 올바른지 판단하기 위해 사전에 정의된참 값을 대입하여 비교하는 기법 및 활동이다.

- 참(True) 오라클 : 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클로, 발생된 모든 오류를 검출할 수 있음
- 샘플링(Sampling) 오라클 : 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클
- 추정(Heuristic) 오라클 : 샘플링 오라클을 개선한 오라클 로, 특정 테스트 케이스의 입력값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클
- 일관성 검사(Consistent) 오라클 : 애플리케이션의 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클

### 테스트 자동화 도구 유형
> 사람이 반복적으로 수행하던 테스트 절차를 테스트 자동화 도구를 사용함으로써 휴먼 에러(Human Error) 를 줄이고 테스트의 정확성을 유지하면서 테스트의 품질을 향상시킬 수 있다.

- 정적 분석 도구(Static Analysis Tools) : 프로그램을 실행 하지 않고 분석하는 도구로, 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함 등을 발견 하기 위해 사용됨
- 테스트 실행 도구(Test Execution Tools) : 스크립트 언어를 사용하여 테스트를 실행하는 방법으로, 테스트 데이터와 테스트 수행 방법 등이 포함된 스크립트를 작성한 후 실행함
- 성능 테스트 도구(Performance Test Tools) : 애플리케이 션의 처리량, 응답 시간, 경과 시간, 자원 사용률 등을 인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부를 확인함
- 테스트 통제 도구(Test Control Tools) : 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구로, 종류에는 형상 관리 도구, 결함 추적/관리 도구 등이 있음
- 테스트 하네스 도구(Test Harness Tools) : 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상 적으로 테스트 되도록 하는 도구

### 결함 관리
> 결함은 오류 발생, 작동 실패 등과 같이 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것을 의미

- 결함 관리 프로세스 처리 순서 : 결함 관리 계획 → 결함 기록 → 결함 검토 → 결함 수정 → 결함 재확인 → 결함 상태 추적 및 모니터링 활동 → 최종 결함 분석 및보고서 작성

![image](https://user-images.githubusercontent.com/81230679/136407618-48263cd3-2c52-4ccd-9eb0-0d04022c5dd4.png)

- 결함 추적 순서 : 결함 등록(Open) → 결함 검토 (Reviewed) → 결함 할당(Assigned) → 결함 수정(Resolved) → 결함 종료(Closed) → 결함 해제 (Clarified)
※ Fixed(고정) : 개발자가 필요한 변경 작업을 수행하여 결함 수정 작업을 완료한 상태

![image](https://user-images.githubusercontent.com/81230679/136407964-88fe9c48-670d-4859-b19f-1b6193fde2a9.png)

- 결함 우선순위 : 결정적(Critical), 높음(High), 보통 (Medium), 낮음(Low) 또는 즉시 해결, 주의 요망, 대기, 개선 권고 등

### 애플리케이션 성능
> 사용자가 요구한 기능을 최소한의 자원을 사용해 최대한 많은 기능을 신속하게 처리하는 정도를 나타냄

![image](https://user-images.githubusercontent.com/81230679/136410626-15b608f4-5a6f-42c0-bacf-d3d1def68f6f.png)

### 소스 코드 최적화
> 나쁜 코드를 배제하고, 클린 코드로  작성하는 것

- 클린 코드 : 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순, 명료한 코드
  - 클린코드 작성 원칙 : 가독성, 단순성, 의존성, 배제, 중복성 최소화, 추상화
- 나쁜 코드 : 코드의 로직이 서로 얽혀있는 스파게티 코드 등 프로그램의 로직이 복잡하고 이해하기 어려운 코드
#### 소스코드 최적화 유형
- 클래스 분할 배치 : 하나의 클래스는 하나의 역할만 수행하도록 응집도를 높이고, 크기를 작게 작성
- 느슨한 결합 : 인터페이스 클래스를 이용해 추상화된 자료 구조와 메소드를 구현함으로써 클래스 간 의존성 최소화
- 코딩 형식 준수, 좋은 이름사용, 적절한 주석

# SQL 응용
