---
title: "[자격증] 정보처리기사 핵심요약"
excerpt: "2021 정기 3회 실기시험 준비"

categories:
  - etc
tags:
  - [정보처리기사, 실기시험]

toc: true
toc_sticky: true

date: 2021-09-29
last_modified_at: 2021-09-29
---

## 변수와 기억 클래스
### 변수
- 컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간, 변할 수 있는 값을 의미
- 저장하는 값에 따라 정수형, 실수형, 문자형, 포인터형 등으로 구분

### 기억 클래스
- 변수 선언 시 메모리 내 변수의 값을 저장하기 위한 기억영역이 할당되는데, 기억영역에 따라 사용 범위에 제한이 있다. 이러한 기억 영역을 결정하는 작업을 지칭
- c언어에서 제공하는 기억 클래스의 종류
  - 자동변수 : 함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수
  - 외부변수 : 현재 파일이나 다른 파일에서 선언된 변수나 함수를 참조하기 위한 변수
  - 정적변수 : 함수나 블록 내에서 선언하는 내부, 함수 외부에서 선언하는 외부 정적변수가 있다
  - 레지스터변수 : 메모리가 아닌 CPU내부의 레지스터에 기억영역을 할당받는 변수

![image](https://user-images.githubusercontent.com/81230679/135219539-84a6a6a4-23e3-4ee5-a780-870401699c1d.png)

<hr>

## Java의 표준 입.출력
- 키보드로 입력받은 값을 변수에 저장하려면 먼저 Scanner클래스를 이용해 키보드로부터 값을 입력받는 객체변수를 생성 후 사용

```java
Scanner scan01 = new Scanner(System.in);
inNum = scan01.netxInt();
```

- Scanner : 입력에 사용할 객체 변수를 생성할 때 사용하는 클래스 이름이다. 그대로 적어준다.
- scan01 : 객체 변수명이다. 사용자 임의로 적어준다.
- new : 객체 생성 예약어이다. 그대로 적어준다.
- Scanner( ) : 클래스의 이름이다. ( )를 붙여 그대로 적어준다.
- System.in : 표준 입력장치, 즉 키보드를 의미한다. 키보드로부터 값을 입력받는 객체 변수를 생성할 것이므로 그대로 적어준다.
- inNum : 입력받은 값을 저장할 변수이다. 이 변수는 미리 선언되어 있어야 한다.
- scan01.nextInt( )
  ▶ scan01 : 입력에 사용할 객체 변수 이름이다. 객체 변수 생성 시 사용한 객체 변수 이름과 동일해야 한다.
  ▶ nextInt( ) : 입력받은 값을 정수형으로 반환한다.
    • next( ) : 입력값을 문자열로 반환
    • nextLine( ) : 입력받은 라인 전체를 문자열로 반환
    • nextInt( ) : 입력값을 정수형으로 반환
    • nextFloat( ) : 입력값을 실수형으로 반환

```java
System.out.printf(서식 문자열, 변수)
```

- System.out.printf( ) : System 클래스의 서브 클래스인 out 클래스의 메소드 printf( )를 사용해서 출력한다는 의미이다.
printf( ) 메소드는 C언어의 printf( ) 함수와 사용법이 동일하다.

![image](https://user-images.githubusercontent.com/81230679/135223072-cd1a1a04-e6a5-433f-827a-bb9fdfdbe814.png)

## 연산자 우선순위

![image](https://user-images.githubusercontent.com/81230679/135225459-d5275a1c-d0a9-4017-9c18-e74a93be4378.png)

![image](https://user-images.githubusercontent.com/81230679/135228259-65a19c9e-5493-4fb5-8f80-5d2119ae26a4.png)


## switch-case
- case문의 레이블에는 한 개의 상수만 지정할 수 있으며, int, char, enum형의 상수만 가능하다.
- case문의 레이블에는 변수를 지정할 수 없다.
- break문은 생략이 가능하지만 break문이 생략되면 수식과 레이블이 일치할 때 실행할 문장부터 break문 또는 switch 문이 종료될 때까지 모든 문장이 실행된다.

## Java에서의 배열과 문자열
### Java에서의 배열 처리
- Java에서는 향상된 for문을 사용할 수 있는데, 향상된 for문은 객체를 대상으로만 가능하다.
- Java에서는 배열을 객체로 취급하며, 배열을 이용하여 작업할 때 필요할 만한 내용은 이미 API로 만들어 두었기 때문에잘 골라서 사용하면 된다.

```java
public class Example {
  public static void main(String[ ] args) {
    int[ ] a = {90,100,80,70,60,50,30};
    int hap = 0;
    float avg;
    for (int i : a)
    // 향상된 반복문. a배열의 요소 수만큼 for문 반복 수행
    // • int i : a 배열의 각 요소가 일시적으로 저장될 변수를 선언. a 배열과 형이 같아야 한다.
    // • a : 배열의 이름을 입력. a 배열이 7개의 요소를 가지므로 각 요소를 i에 저장하면서 7번 수행
    hap = hap + i;
    avg = (float)hap / a.length;
    System.out.printf("%d, %.2f", hap, avg);
  }
}
```

### Java에서의 문자열
- Java에서는 문자열을 처리할 수 있도록 클래스를 제공하므로 그에 따른 속성과 메소드도 당연히 지원하는데 여기서는 문제 풀이에 꼭 필요한 속성과 메소드만 학습한다.

```java
public class Example {
  public static void main(String[ ] args){
    String str = "Information!";
    int n = str.length( );
    char[ ] st = new char [n];
    n--;
    for (int k = n; k >= 0; k--) {
      st[n-k] = str.charAt(k);
      //charAt() 메소드는 해당 문자열에서 인수에 해당하는 위치의 문자열을 반환한다.
    }
    for (char k : st) {
      System.out.printf("%c", k);
    }
  }
}
```

## 포인터
### 포인터와 변수
- 포인터는 변수의 주소
- c언어에서는 주소를 제어할 수 있는 기능을 제공하며 변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라 함
- 포인터 변수 선언 시 자료형을 먼저 쓰고 변수명 앞에 간접 연산자 `*`사용( ex : `int *a;` )
- 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지연산자 `&`사용( ex : `a = &b;` )
- 실행문에서 포인터 변수에 간접 연산자 `*`를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말함( ex : `c = *a;` )

### 포인터와 배열
- 배열을 포인터 변수에 저장 후 포인터를 이용해 배열의 요소에 접근
- 배열 위치를 나타내는 첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같음

```c
int a[5], *b
b = a
// 배열의 대표명을 적었으므로 a 배열의 시작 주소인 a[0]의 주소를 b에 저장한다.
b = &a[0]
// a 배열의 첫 번째 요소인 a[0]의 주소(&)를 b에 저장한다.
```

![image](https://user-images.githubusercontent.com/81230679/135272124-d1e135b1-3e91-45ed-a9b7-667d0cb52e53.png)

## Java의 클래스와 메소드
- 클래스는 객체 생성을 위한 필드(속성)와 메소드(함수)를 정의하는 설계도로 Java는 아무리 작은 프로그램 이라도 클래스를 만들어 사용해야 함

```java
public class Example {
  static class AAclass {        // AAclass 클래스를 정의한다. 클래스 안에 클래스를 정의할 때는 static을 붙인다.
    int i;                               // •class : 클래스를 정의하는 명령어로, 꼭 써야하는 예약어이다.
    int j;
  }

  public static void main(String[ ] args) {
    AAclass myVal = new AAclass( );
    myVal.i = 10;
    myVal.j = 20;
    myVal = change(myVal);
    System.out.printf("i=%d, j=%d\n", myVal.i, myVal.j);
  }
  static AAclass change(AAclass myVal) {
    int temp;
    temp = myVal.i;
    myVal.i = myVal.j;
    myVal.j = temp;
    return myVal;
  }
}
```

## Python의 기초
### input() 함수
- Python의 표준 입력 함수로, 키보드로 입력받아 변수에 저장하는 함수
- 입력되는 값은 문자열로 취급되어 저장됨

```python
변수 = input(출력문자)
# 출력문자는 생략가능, 값을 입력하고 enter를 누르면 입력한 값이 '변수'에 저장
변수1, 변수2. ... = input(출력문자).split(분리문자)
# 화면에 '출력문자'가 표시되고 입력받은 값을 '분리문자'로 구분해 각각 변수1, 변수2, ... 에 저장, '분리문자'생략 시 공백
```

### print() 함수
- Python의 표준 출력 함수로, 값을 화면에 출력하는 함수

```python
print(출력값1, 출력값2, ..., sep = 분리분자, end = 종료문자)
# '출력값'에는 숫자, 문자, 문자열, 변수 등 다양한 값이나 식
# 'sep'는 여러값을 출력할 때 값과 값 사이 구분하는 문자, 생략할 경우 기본 값은 공백 한칸(' ')
# 'end'는 맨 마지막에 표시할 문자로 생략할 경우 기본 값은 줄 나눔
print(서식 문자열 % (출력값1, 출력값2, ...))
# C와 Java에서 사용했던 서식 문자열 동일 적용, 출력값이 한 개일 경우 출력값에 대한 괄호 생략 가능
```

### List
- C, Java에서는 여러 요소들을 한 개의 이름으로 처리할 때 배열을 사용하지만 Python에서는 리스트를 사용

```python
# 1차원 리스트 형식
리스트명 = [값1, 값2,...]
리스트명 - list([값1, 값2, ...])
# 2차원 리스트 형식
리스트명 = [
  [값1, 값2, 값3],
  [값4, 값5, 값6]]
  리스트A = [값1, 값2, 값3]
  리스트B = [값4, 값5, 값6]
  리스트명 = [리스트A, 리스트B]
  ```

### Range
  - 연속된 숫자를 생성하는 것(리스트, 반복문 등에서 많이 사용)

```python
range(최종값)
# 0에서 '최종값-1'까지 연속된 숫자 생성
range(초기값, 최종값)
# '초기값'에서 '최종값-1'까지 연속된 숫자를 생성
range(초기값, 중간값, 최종값)
# '초기값'에서 '최종값-1'까지 '증가값'만큼 증가하며 숫자 생성, '증가값'이 음수인 경우 '초기값'에서 '최종값+1'까지 '증가값'만큼 감소하며 숫자생성
```

### Slice
- 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라 반환하는 기능

```python
객체명[초기위치:최종위치]
객체명[초기위치:최종위치:증가값]
# slice는 일부 인수를 생략해 사용할 수 있음
객체명[:] 또는 객체명[::]     #객체의 모든 요소 반환
객체명[초기위치:]               #객체의 '초기위치'에서 마지막까지 반환
객체명[:최종위치]               #객체의 0번째 위치에서 '최종위치-1'까지의 요소 반환
객체명[::증가값]                 #객체의 0번째 위치에서 마지막 위치까지 '증가값'만큼 증가하며 해당 위치의 요소들을 반환
```

<img width="779" alt="스크린샷 2021-10-01 오후 4 05 46" src="https://user-images.githubusercontent.com/81230679/135579420-15316c0f-c645-4f1b-b767-48507c0f468b.png">

## 라이브러리

<img width="805" alt="스크린샷 2021-10-01 오후 4 21 07" src="https://user-images.githubusercontent.com/81230679/135581258-eb78ed2f-9220-44ba-8274-0a2a4b0c3962.png">

<img width="805" alt="스크린샷 2021-10-01 오후 4 22 32" src="https://user-images.githubusercontent.com/81230679/135581389-f21eeb36-1cc6-459d-ae7e-2871563031ab.png">

## 절차적 프로그래밍 언어
- C : 1972 미국 벨 연구소 데니스 리치. 시스템의 SW개발하기 편리해 시스템 프로그래밍 언어로 널리 사용. 포인터 제공. 고급과 저급특징. UNX의 일부가 C언어. 컴파일러 방식의. 이식성이 좋음
- ALGOL : 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어. PASCAL, C언어의 모체
- COBOL : 사무 처리용 언어. 영어 문장 형식으로 구성. 4개의 DIVISION으로 구성
- FORTRAN : 과학 기술 계산용 언어. 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 가능

## 객체지향 프로그래밍 언어
- Java : 분산 네트워크 환경에 적용 가능. 멀테스레드 기능 제공(멀티태스킹). OS, HW에 독립적이며 이식성 좋음. 캡슐화 가능, 재사용성 높음
- C++ : C언어에 객체지향 개념 적용. 모든 문제를 객체로 모델링해 표현
- Smalltalk : 1세대 객체지향 언어 중 하나로 순수한 객체지향 프로그래밍 언어. 최초로 GUI제공

### 객체지향 프로그래밍 언어의 구성 요소
- 객체(Object)
  - 데이터(속성)와 이를 처리하기 위한 연산(메소드)을 결합시킨 실체
  - 속성 : 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의하는 것으로서 성질, 분류, 식별, 수량 또는 현재 상태등을 표현
  - 메소드 : 객체가 메시지를 받아 실행해야 할 때 구체적인 연산을 정의하는 것, 객체의 상태를 참조하거나 변경하는 수단이 됨
- 클래스
  - 두 개 이상의 유사한 객체들을 묶어 하나의 공통된 특성을 표현하는 요소. 공통된 특성과 행위를 갖는 객체의 집합
  - 데이터를 추상화하는 단위
- 메시지
  - 객체들 간 상호작용을 하는데 사용되는 수단으로 객체의 메소드를 일으키는 외부의 요구사항

### 객체지향 프로그래밍 언어의 특징

<img width="804" alt="스크린샷 2021-10-01 오후 4 37 08" src="https://user-images.githubusercontent.com/81230679/135583128-9f3ed275-08cf-47c2-9e70-83e821677894.png">

## 스크립트 언어
- HTML 문서 안에 직접 프로그래밍 언어를 삽입해 사용하는 것, 기계어로 컴파일 되지 않고 별도의 번역기가 소스를 분석해 동작하게 하는 언어

### 서버용 스크립트 언어
- 서버에서 해석돼 실행된 후 결과만 클라이언트로 보내는 스크립트 언어
- ASP, JSP, PHP, PYTHON, PERL, RUBY

### 클라이언트용 스크립트 언어
- 클라이언트 웹 브라우저에서 해석돼 실행되는 스크립트 언어
- JS, VB 스크립트 등

### 스크립트 언어의 종류
- 자바 스크립트 : 넷스케이프의 브렌던 아이크가 개발한 언어로 웹 페이지의 동작을 제어, 변수 선언이 필요 없음
- ASP : 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 MS에서 제작했으며 windows 계열에서만 수행 가능한 프로그래밍 언어
- JSP : 자바로 만들어진 스크립트 언어로 다양한 os에서 사용 가능
- PHP : 서버용 스크립트 언어로 리눅스. 유닉스, 윈도우 os에서 사용 가능, c, java와 문법이 유사
- 파이썬 : 객체지향 기능을 지원하는 대화형 인터프리터 언어로 플랫폼에 독립적이고 문법이 간단해 배우기 쉬움

## 선언형 언어
### 함수형 언어
- 수학적 함수를 조합해 문제해결. 알려진 값을 함수에 적용하는 것을 기반으로 함(LISP)

### 논리형 언어
- 기호 논리학에 기반을 둔 언어, 논리 문장을 이용해 계산 수행(PROLOG)

<img width="799" alt="스크린샷 2021-10-01 오후 5 19 43" src="https://user-images.githubusercontent.com/81230679/135588446-d57f6ecc-f930-4cb6-92b1-4beef5c5f37b.png">

<hr>

# 요구사항 확인
### 현행 시스템 파악 절차
- 시스템 구성 파악 : 조직의 주요 업무를 담당하는 기간 업무와 이를 지원하는 지원 업무로 구분해 기술
- 시스템 기능 파악 : 단위 업무 시스템이 현재 제공하는 기능들을 주요기능과 하부기능, 세부기능으로 구분해 계층형으로 표시
- 시스템 인터페이스 파악 : 단위 업무 시스템 간 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등 명시
- 아키텍쳐 구성 파악 : 기간 업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성
- SW 구성 파악 : 설치되어 있는 SW의 제품명, 용도, 라이센스 적용 방식, 라이센스 수 등 명시
- HW 구성 파악 : 서버의 주요 사양과 수량, 이중화의 적용 여부 명시
- 네트워크 구성 파악 : 업무 시스템들의 네트워크 구성을 파악할 수 있도록 서버의 위치, 서버간 네트워크 연결 방식을 네트워크 구성도로 작성

### 개발 기술 환경
> 개발하고자 하는 SW와 관련된 OS, DB관리 시스템, 미들웨어 등 선정 시 고려사항 기술, 오픈소스 사용 시 주의사항 제시
- OS : 시스템의 자원관리, 사용환경 제공. 가용성, 성능, 기술 지원, 주변 기기, 구축 비용 등 고려
- DB 관리 시스템 : 요구에 따른 정보생성, DB관리. 가용성, 성능, 기술지원, 상호 호환성, 구축 비용 등 고려
- WAS : 동적인 콘텐츠 처리를 위한 미들웨아. 가용성, 성능, 기술지원, 구축비용 등 고려
- 오픈소스 : 라이센스 종류, 사용자 수, 기술의 지속 가능성 등 고려

### 요구사항 유형
- 기능 : 시스템이 갖춰야할 필수적인 기능
- 비기능 : 필수 기능 외 품질이나 제약사항 관련
- 사용자 : 사용자 관점) 시스템이 제공해야 할 요구사항
- 시스템 : 개발자 관점) 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항

### 요구사항 개발 프로세스
- 도출 : 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스 기법 이용
- 분석 : 불명확, 모호한 부분 발견 및 필터링. 비용과 일정에 대한 제약 설정, 타당성 조사
  - 요구사항 분류 : 명확한 확인을 위한 요구사항 분류
  - 개념 모델링 : 쉬운 이해를 위해 상황 단순화 및 개념적으로 표현. 유스케이스 다이어그램, 데이터 흐름 모델, 상태 모델, 목표기반 모델, 사용자 인터액션, 객체 모델, 데이터 모델 등
  - 요구사항 할당 : 요구사항 만족을 위한 구성 요소 식별
  - 요구사항 협상 : 요구사항 충돌 시 해결
  - 정형 분석 : 정형화된 언어를 이용해 요구사항을 수학적 기호로 표현
- 명세 : 체계적 분석 후 승인 가능하도록 문서화
- 확인 : 명세서의 정확성 완전성 검토
  - 요구사항 검토 : 문서화된 요구사항 확인
  - 프로토타이핑 : 초기 도출된 요구사항을 토대로 프로토타입 제작 후 지속적인 업데이트
  - 모델 검증 : 분석단계에서 개발된 모델의 요구사항 충족여부 검증
  - 인수 테스트 : 실제 환경에서 요구사항들이 모두 충족되느니 사용자 입장에서 확인

#### 자료 흐름도(Data Flow Diagram)
> 요구사항 분석에서 자료의 흐름 및 변환과정과 기능을 도형 중심으로 기술하는 방법
- 프로세스 : 자료를 변환시키는 시스템의 한 부분. 처리, 기능, 변환, 버블 이라고 하며 원, 둥근 사각형으로 표시하며 프로세스 이름 기입
- 자료 흐름 ; 자료의 이동, 연관 관게 표시. 화살표 위에 자료의 이름 기입
- 자료 저장소 : 시스템에서의 자료 저장소 나타냄. 도형 안에서 자료 저장소 이름 기입
- 단말 : 시스템과 교신하는 외부 개체. 도형 안에 이름 기입

### UML(Unified Modeling Language)
> 시스템 개발 과정(분석, 설계, 구현)에서 시스템 개발자와 고객 또는 개발자 상호 간 의사소통이 원할하게 이루어 지도록 표준화한 대표적인 객체지향 모델링 언어로 아래 3가지로 구성
- 사물 : 관계가 형성될 수 있는 대상들
  - 구조사물 : 시스템의 개념적, 물리적 요소표현
  - 행동사물 : 시공간에 따른 요소들의 행위 표현
  - 그룹사물 : 요소들을 그룹으로 묶어 표현
  - 주해사물 : 부가설명이나 제약조건 표현
- 관계 : 사물과 사물 사이의 연관성을 표현하는 것
  - 연관, 집합, 포함(포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 집합의 특수한 형태), 일반화, 의존(필요에 의해 짧은 시간만 연관), 실체화
- 다이어그램 : 사물과 관계를 도형으로 표현한 것
  - 정적 모델링 : 구조적 다이어그램 사용
  - 동적 모델링 : 행위 다이어그램 사용

#### 구조적 다이어그램
##### 클래스 다이어그램 : 클래스와 클래스가 가지는 속성, ㅋ르래스 사이의 관계 표현(정적 모델링의 대표)
- 클래스 : 각 개체들이 갖는 속성과 동작표현. 이름/속성(클래스의 상태나 정보 표현)/동작(함수)
- 제약조건
- 관계 : 클래스 간 연관성 표현
##### 객체 다이어그램 : 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
##### 컴포넌트 다이어그램 : 컴포넌트 간 관계, 인터페이스 표현
##### 배치 다이어그램 : 물리적 요소들의 위치 표현(결과물, 프로세스, 컴포넌트 등)
##### 복합체 구조 다이어그램 : 복합 구조를 갖는 경우 내부 구조 표현
##### 패키지 다이어그램 : 유스케이스나 클래스등의 모델 요소들을 그룹화한 패키지들의 관계 표현

#### 행위 다이어그램
> 행위 다이어그램에는 동적 모델링인 시퀀스 다이어그램, 커뮤니케이션 다이어그램, 상태 다이어그램, 기능 모델링인 유스케이스(Use Case) 다이어 그램, 활동(Activity) 다이어그램 등이 있다.

##### 시퀀스 다이어그램
- 시스템,객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호 작용하는 과정 표현
- 액터 : 시스템으로부터 서비스를 요청하는 외부요소(사람 or 외부 시스템)
- 객체 : 메시지를 주고받는 주체로 `;`을 기준으로 앞-객체명, 뒤-클래스명 기술
- 라이프라인 : 객체가 메모리에 존재하는 기간(객체 아래 점선 그어 표현)
- 활성 상자 : 객체가 메시지를 주고받으며 구동되고 있음을 라이프라인 상에 겹쳐 직사각형 형태로 표현
- 메시지 : 객체 간 주고받음
- 객체 소멸 : 라이프라인 상 소멸 표시를 만나면 해당 객체는 더 이상 메모리에 존재하지 않음을 의미
- 프레임 : 다이어그램의 전체 또는 일부를 묶어 표현

##### 커뮤니케이션 다이어그램
- 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하나, 객체들 간 연관까지 표현
- 액터, 객체
- 링크 : 객체들 간 관계 표현, 액터와 객체, 객체 간 실선으로 표현

##### 상태 다이어그램
- 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는 지 표현
- 상태 : 객체의 상태를 둥근 사각형 안에 기술. **●**-시작상태, **⊙**-종료상태
- 이벤트 : 조건, 외부신호, 시간 등 상태에 변화를 주는 현상
- 상태 전환 : 상태 사이의 흐름, 변화 화살표로 표현
- 프레임 : 상태 다이어그램의 범위 표현

##### 유스케이스 다이어그램
- 사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현
- 시스템 범위 : 내부/외부 구분을 위해 시스템 내부의 유스케에스들을 사각형으로 묶어 시스템의 범위 표현
- 액터 : 시스템과 상호작용 하는 모든 외부 요소
- 유스케이스 : 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능
- 관계 : 액터와 유스케이스, 유스케이스와 유스케이스. 포함 관계, 확정 관계, 일반화 관계

##### 활동 다이어그램
- 자료흐름도와 유사, 사용자 관점ㅇ에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현
- 액티비티 : 액션(더 이상 분해할 수 없는 단일 작업)으로 분리될 수 있는 작업
- 노드 : 시작 노드, 종료 노드, 조건(판단) 노드 : 조건에 따라 제어의 흐름 분리, 포그(Fork)노드 : 액티비티 흐름이 분리되어 수행됨, 조인(Join)노드 : 분리되어 수행되던 앧티비티 흐름이 다시 합쳐짐
- 스윔레인 : 액티비티 수행을 담당하는 주체를 구문

# 데이터 입출력 구현
> 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화해 체계적으로 표현한 개념적 모형
## 데이터 모델
### 구성 요소
  - 개체 : DB에 표현하려는 것, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
  - 속성 : 데이터의 가장 작은 논리적 단위. 파일 구조상 데이터 항목 또는 데이터 필드
  - 관계 : 개체 간 관계, 속성 간 논리적인 연결

### 종류
#### 개념적 데이터 모델
  : 현실 세계에 대한 인가의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
#### 논리적 데이터 모델
  : 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리하도록 컴퓨터 세계의 환경에 맞춰 변환하는 과정
#### 물리적 데이터 모델
  : 실제 컴퓨터에 데이터가 저장되는 방법을 정의하는 물리 DB설계 과정

#### 데이터 모델에 표시할 요소
- 구조 : 논리적으로 표현된 개체 타입들 간 관계로 데이터 구조 및 정적 성질 표현
- 연산 : DB에 저장된 실제 데이터를 처리하는 작업에 대한 명세. DB를 조작하는 기본 도구
- 제약 조건 : 저장될 수 있는 실제 데이터의 논리적인 제약 조건

## 이상(Anomaly)
- 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복발생 및 이로 인한 테이블 조작 시 문제 발생
### 이상의 종류
- 삽입 이상 : 테이블에 데이터를 삽입 시 원하지 않은 값들로 인해 삽입 불가능
- 삭제 이상 : 테이블 내 한 튜플 삭제 시 상관없는 값들도 함께 삭제(연쇄 삭제) 발생
- 갱신 이상 : 테이블 내 튜플에 있는 속성값 갱신 시 일부 튜플의 정보만 갱신되어 정보에 불일치성 발생

### 함수적 종속
> 어떤 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라 할 때 속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을때 Y는 X에 함수적 종속 또는 X가 Y를 함수적으로 결정한다고 하고, X → Y로 표기한다. X → Y의 관계를 갖는 속성 X와 Y에서 X를 결정자 (Determinant)라 하고, Y를 종속자(Dependent)라고 한다.

- 완전 함수적 종속 : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 어떠한 진부분 집합 Z(즉, Z ⊂ X)에도 함수적 종속이 아닐 때 속성 Y는 속성 집합 X에 완전 함수적 종속이라고 함
- 부분 함수적 종속 : 부분 함수적 종속 : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 임의의 진부분 집합에 대해 함수적 종속일 때, 속성 Y는 속성 집합 X에 부분 함수적 종속이라고 함

### 정규화(Normalization)
> 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용해 테이블을 무손실 분해하는 과정

- 정규화 과정

![image](https://user-images.githubusercontent.com/81230679/135783528-5409a403-327c-493a-944d-c76258cf0c32.png)

※ 이행적 함수족 종속 : A → B이고 B → C일 때 A → C 를 만족하는 관계를 이행적 함수적 종속이라고 함

### 반정규화(Denormalization)
> 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정. 의도적으로 정규화 원칙을 위배하는 행위

