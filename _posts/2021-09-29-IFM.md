---
title: "[자격증] 정보처리기사 핵심요약"
excerpt: "2021 정기 3회 실기시험 준비"

categories:
  - etc
tags:
  - [정보처리기사, 실기시험]

toc: true
toc_sticky: true

date: 2021-09-29
last_modified_at: 2021-09-29
---

## 변수와 기억 클래스
### 변수
- 컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간, 변할 수 있는 값을 의미
- 저장하는 값에 따라 정수형, 실수형, 문자형, 포인터형 등으로 구분

### 기억 클래스
- 변수 선언 시 메모리 내 변수의 값을 저장하기 위한 기억영역이 할당되는데, 기억영역에 따라 사용 범위에 제한이 있다. 이러한 기억 영역을 결정하는 작업을 지칭
- c언어에서 제공하는 기억 클래스의 종류
  - 자동변수 : 함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수
  - 외부변수 : 현재 파일이나 다른 파일에서 선언된 변수나 함수를 참조하기 위한 변수
  - 정적변수 : 함수나 블록 내에서 선언하는 내부, 함수 외부에서 선언하는 외부 정적변수가 있다
  - 레지스터변수 : 메모리가 아닌 CPU내부의 레지스터에 기억영역을 할당받는 변수

![image](https://user-images.githubusercontent.com/81230679/135219539-84a6a6a4-23e3-4ee5-a780-870401699c1d.png)

<hr>

## Java의 표준 입.출력
- 키보드로 입력받은 값을 변수에 저장하려면 먼저 Scanner클래스를 이용해 키보드로부터 값을 입력받는 객체변수를 생성 후 사용

```java
Scanner scan01 = new Scanner(System.in);
inNum = scan01.nextInt();
```

- Scanner : 입력에 사용할 객체 변수를 생성할 때 사용하는 클래스 이름이다. 그대로 적어준다.
- scan01 : 객체 변수명이다. 사용자 임의로 적어준다.
- new : 객체 생성 예약어이다. 그대로 적어준다.
- Scanner( ) : 클래스의 이름이다. ( )를 붙여 그대로 적어준다.
- System.in : 표준 입력장치, 즉 키보드를 의미한다. 키보드로부터 값을 입력받는 객체 변수를 생성할 것이므로 그대로 적어준다.
- inNum : 입력받은 값을 저장할 변수이다. 이 변수는 미리 선언되어 있어야 한다.
- scan01.nextInt( )

▶ scan01 : 입력에 사용할 객체 변수 이름이다. 객체 변수 생성 시 사용한 객체 변수 이름과 동일해야 한다.<br/>
▶ nextInt( ) : 입력받은 값을 정수형으로 반환한다.<br/>
  • next( ) : 입력값을 문자열로 반환<br/>
  • nextLine( ) : 입력받은 라인 전체를 문자열로 반환<br/>
  • nextInt( ) : 입력값을 정수형으로 반환<br/>
  • nextFloat( ) : 입력값을 실수형으로 반환<br/>

```java
System.out.printf(서식 문자열, 변수)
```

- System.out.printf( ) : System 클래스의 서브 클래스인 out 클래스의 메소드 printf( )를 사용해서 출력한다는 의미이다.
printf( ) 메소드는 C언어의 printf( ) 함수와 사용법이 동일하다.

![image](https://user-images.githubusercontent.com/81230679/135223072-cd1a1a04-e6a5-433f-827a-bb9fdfdbe814.png)

## 연산자 우선순위

![image](https://user-images.githubusercontent.com/81230679/135225459-d5275a1c-d0a9-4017-9c18-e74a93be4378.png)

![image](https://user-images.githubusercontent.com/81230679/135228259-65a19c9e-5493-4fb5-8f80-5d2119ae26a4.png)


## switch-case
- case문의 레이블에는 한 개의 상수만 지정할 수 있으며, int, char, enum형의 상수만 가능하다.
- case문의 레이블에는 변수를 지정할 수 없다.
- break문은 생략이 가능하지만 break문이 생략되면 수식과 레이블이 일치할 때 실행할 문장부터 break문 또는 switch 문이 종료될 때까지 모든 문장이 실행된다.

## Java에서의 배열과 문자열
### Java에서의 배열 처리
- Java에서는 향상된 for문을 사용할 수 있는데, 향상된 for문은 객체를 대상으로만 가능하다.
- Java에서는 배열을 객체로 취급하며, 배열을 이용하여 작업할 때 필요할 만한 내용은 이미 API로 만들어 두었기 때문에잘 골라서 사용하면 된다.

```java
public class Example {
  public static void main(String[ ] args) {
    int[ ] a = {90,100,80,70,60,50,30};
    int hap = 0;
    float avg;
    for (int i : a)
    // 향상된 반복문. a배열의 요소 수만큼 for문 반복 수행
    // • int i : a 배열의 각 요소가 일시적으로 저장될 변수를 선언. a 배열과 형이 같아야 한다.
    // • a : 배열의 이름을 입력. a 배열이 7개의 요소를 가지므로 각 요소를 i에 저장하면서 7번 수행
    hap = hap + i;
    avg = (float)hap / a.length;
    System.out.printf("%d, %.2f", hap, avg);
  }
}
```

### Java에서의 문자열
- Java에서는 문자열을 처리할 수 있도록 클래스를 제공하므로 그에 따른 속성과 메소드도 당연히 지원하는데 여기서는 문제 풀이에 꼭 필요한 속성과 메소드만 학습한다.

```java
public class Example {
  public static void main(String[ ] args){
    String str = "Information!";
    int n = str.length( );
    char[ ] st = new char [n];
    n--;
    for (int k = n; k >= 0; k--) {
      st[n-k] = str.charAt(k);
      //charAt() 메소드는 해당 문자열에서 인수에 해당하는 위치의 문자열을 반환한다.
    }
    for (char k : st) {
      System.out.printf("%c", k);
    }
  }
}
```

## 포인터
### 포인터와 변수
- 포인터는 변수의 주소
- c언어에서는 주소를 제어할 수 있는 기능을 제공하며 변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라 함
- 포인터 변수 선언 시 자료형을 먼저 쓰고 변수명 앞에 간접 연산자 `*`사용( ex : `int *a;` )
- 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지연산자 `&`사용( ex : `a = &b;` )
- 실행문에서 포인터 변수에 간접 연산자 `*`를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말함( ex : `c = *a;` )

### 포인터와 배열
- 배열을 포인터 변수에 저장 후 포인터를 이용해 배열의 요소에 접근
- 배열 위치를 나타내는 첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같음

```c
int a[5], *b
b = a
// 배열의 대표명을 적었으므로 a 배열의 시작 주소인 a[0]의 주소를 b에 저장한다.
b = &a[0]
// a 배열의 첫 번째 요소인 a[0]의 주소(&)를 b에 저장한다.
```

![image](https://user-images.githubusercontent.com/81230679/135272124-d1e135b1-3e91-45ed-a9b7-667d0cb52e53.png)

## Java의 클래스와 메소드
- 클래스는 객체 생성을 위한 필드(속성)와 메소드(함수)를 정의하는 설계도로 Java는 아무리 작은 프로그램 이라도 클래스를 만들어 사용해야 함

```java
public class Example {
  static class AAclass {        // AAclass 클래스를 정의한다. 클래스 안에 클래스를 정의할 때는 static을 붙인다.
    int i;                               // •class : 클래스를 정의하는 명령어로, 꼭 써야하는 예약어이다.
    int j;
  }

  public static void main(String[ ] args) {
    AAclass myVal = new AAclass( );
    myVal.i = 10;
    myVal.j = 20;
    myVal = change(myVal);
    System.out.printf("i=%d, j=%d\n", myVal.i, myVal.j);
  }
  static AAclass change(AAclass myVal) {
    int temp;
    temp = myVal.i;
    myVal.i = myVal.j;
    myVal.j = temp;
    return myVal;
  }
}
```

## Python의 기초
### input() 함수
- Python의 표준 입력 함수로, 키보드로 입력받아 변수에 저장하는 함수
- 입력되는 값은 문자열로 취급되어 저장됨

```python
변수 = input(출력문자)
# 출력문자는 생략가능, 값을 입력하고 enter를 누르면 입력한 값이 '변수'에 저장
변수1, 변수2. ... = input(출력문자).split(분리문자)
# 화면에 '출력문자'가 표시되고 입력받은 값을 '분리문자'로 구분해 각각 변수1, 변수2, ... 에 저장, '분리문자'생략 시 공백
```

### print() 함수
- Python의 표준 출력 함수로, 값을 화면에 출력하는 함수

```python
print(출력값1, 출력값2, ..., sep = 분리분자, end = 종료문자)
# '출력값'에는 숫자, 문자, 문자열, 변수 등 다양한 값이나 식
# 'sep'는 여러값을 출력할 때 값과 값 사이 구분하는 문자, 생략할 경우 기본 값은 공백 한칸(' ')
# 'end'는 맨 마지막에 표시할 문자로 생략할 경우 기본 값은 줄 나눔
print(서식 문자열 % (출력값1, 출력값2, ...))
# C와 Java에서 사용했던 서식 문자열 동일 적용, 출력값이 한 개일 경우 출력값에 대한 괄호 생략 가능
```

### List
- C, Java에서는 여러 요소들을 한 개의 이름으로 처리할 때 배열을 사용하지만 Python에서는 리스트를 사용

```python
# 1차원 리스트 형식
리스트명 = [값1, 값2,...]
리스트명 - list([값1, 값2, ...])
# 2차원 리스트 형식
리스트명 = [
  [값1, 값2, 값3],
  [값4, 값5, 값6]]
  리스트A = [값1, 값2, 값3]
  리스트B = [값4, 값5, 값6]
  리스트명 = [리스트A, 리스트B]
  ```

### Range
  - 연속된 숫자를 생성하는 것(리스트, 반복문 등에서 많이 사용)

```python
range(최종값)
# 0에서 '최종값-1'까지 연속된 숫자 생성
range(초기값, 최종값)
# '초기값'에서 '최종값-1'까지 연속된 숫자를 생성
range(초기값, 최종값, 증가값)
# '초기값'에서 '최종값-1'까지 '증가값'만큼 증가하며 숫자 생성, '증가값'이 음수인 경우 '초기값'에서 '최종값+1'까지 '증가값'만큼 감소하며 숫자생성
```

### Slice
- 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라 반환하는 기능

```python
객체명[초기위치:최종위치]
객체명[초기위치:최종위치:증가값]
# slice는 일부 인수를 생략해 사용할 수 있음
객체명[:] 또는 객체명[::]     #객체의 모든 요소 반환
객체명[초기위치:]               #객체의 '초기위치'에서 마지막까지 반환
객체명[:최종위치]               #객체의 0번째 위치에서 '최종위치-1'까지의 요소 반환
객체명[::증가값]                 #객체의 0번째 위치에서 마지막 위치까지 '증가값'만큼 증가하며 해당 위치의 요소들을 반환
```

<img width="779" alt="스크린샷 2021-10-01 오후 4 05 46" src="https://user-images.githubusercontent.com/81230679/135579420-15316c0f-c645-4f1b-b767-48507c0f468b.png">

## 라이브러리

<img width="805" alt="스크린샷 2021-10-01 오후 4 21 07" src="https://user-images.githubusercontent.com/81230679/135581258-eb78ed2f-9220-44ba-8274-0a2a4b0c3962.png">

<img width="805" alt="스크린샷 2021-10-01 오후 4 22 32" src="https://user-images.githubusercontent.com/81230679/135581389-f21eeb36-1cc6-459d-ae7e-2871563031ab.png">

## 절차적 프로그래밍 언어
- C : 1972 미국 벨 연구소 데니스 리치. 시스템의 SW개발하기 편리해 시스템 프로그래밍 언어로 널리 사용. 포인터 제공. 고급과 저급특징. UNX의 일부가 C언어. 컴파일러 방식의. 이식성이 좋음
- ALGOL : 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어. PASCAL, C언어의 모체
- COBOL : 사무 처리용 언어. 영어 문장 형식으로 구성. 4개의 DIVISION으로 구성
- FORTRAN : 과학 기술 계산용 언어. 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 가능

## 객체지향 프로그래밍 언어
- Java : 분산 네트워크 환경에 적용 가능. 멀테스레드 기능 제공(멀티태스킹). OS, HW에 독립적이며 이식성 좋음. 캡슐화 가능, 재사용성 높음
- C++ : C언어에 객체지향 개념 적용. 모든 문제를 객체로 모델링해 표현
- Smalltalk : 1세대 객체지향 언어 중 하나로 순수한 객체지향 프로그래밍 언어. 최초로 GUI제공

### 객체지향 프로그래밍 언어의 구성 요소
- 객체(Object)
  - 데이터(속성)와 이를 처리하기 위한 연산(메소드)을 결합시킨 실체
  - 속성 : 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의하는 것으로서 성질, 분류, 식별, 수량 또는 현재 상태등을 표현
  - 메소드 : 객체가 메시지를 받아 실행해야 할 때 구체적인 연산을 정의하는 것, 객체의 상태를 참조하거나 변경하는 수단이 됨
- 클래스
  - 두 개 이상의 유사한 객체들을 묶어 하나의 공통된 특성을 표현하는 요소. 공통된 특성과 행위를 갖는 객체의 집합
  - 데이터를 추상화하는 단위
- 메시지
  - 객체들 간 상호작용을 하는데 사용되는 수단으로 객체의 메소드를 일으키는 외부의 요구사항

### 객체지향 프로그래밍 언어의 특징

<img width="804" alt="스크린샷 2021-10-01 오후 4 37 08" src="https://user-images.githubusercontent.com/81230679/135583128-9f3ed275-08cf-47c2-9e70-83e821677894.png">

## 스크립트 언어
- HTML 문서 안에 직접 프로그래밍 언어를 삽입해 사용하는 것, 기계어로 컴파일 되지 않고 별도의 번역기가 소스를 분석해 동작하게 하는 언어

### 서버용 스크립트 언어
- 서버에서 해석돼 실행된 후 결과만 클라이언트로 보내는 스크립트 언어
- ASP, JSP, PHP, PYTHON, PERL, RUBY

### 클라이언트용 스크립트 언어
- 클라이언트 웹 브라우저에서 해석돼 실행되는 스크립트 언어
- JS, VB 스크립트 등

### 스크립트 언어의 종류
- 자바 스크립트 : 넷스케이프의 브렌던 아이크가 개발한 언어로 웹 페이지의 동작을 제어, 변수 선언이 필요 없음
- ASP : 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 MS에서 제작했으며 windows 계열에서만 수행 가능한 프로그래밍 언어
- JSP : 자바로 만들어진 스크립트 언어로 다양한 os에서 사용 가능
- PHP : 서버용 스크립트 언어로 리눅스. 유닉스, 윈도우 os에서 사용 가능, c, java와 문법이 유사
- 파이썬 : 객체지향 기능을 지원하는 대화형 인터프리터 언어로 플랫폼에 독립적이고 문법이 간단해 배우기 쉬움

## 선언형 언어
### 함수형 언어
- 수학적 함수를 조합해 문제해결. 알려진 값을 함수에 적용하는 것을 기반으로 함(LISP)

### 논리형 언어
- 기호 논리학에 기반을 둔 언어, 논리 문장을 이용해 계산 수행(PROLOG)

<img width="799" alt="스크린샷 2021-10-01 오후 5 19 43" src="https://user-images.githubusercontent.com/81230679/135588446-d57f6ecc-f930-4cb6-92b1-4beef5c5f37b.png">

<hr>

# 요구사항 확인
### 현행 시스템 파악 절차
- 시스템 구성 파악 : 조직의 주요 업무를 담당하는 기간 업무와 이를 지원하는 지원 업무로 구분해 기술
- 시스템 기능 파악 : 단위 업무 시스템이 현재 제공하는 기능들을 주요기능과 하부기능, 세부기능으로 구분해 계층형으로 표시
- 시스템 인터페이스 파악 : 단위 업무 시스템 간 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등 명시
- 아키텍쳐 구성 파악 : 기간 업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성
- SW 구성 파악 : 설치되어 있는 SW의 제품명, 용도, 라이센스 적용 방식, 라이센스 수 등 명시
- HW 구성 파악 : 서버의 주요 사양과 수량, 이중화의 적용 여부 명시
- 네트워크 구성 파악 : 업무 시스템들의 네트워크 구성을 파악할 수 있도록 서버의 위치, 서버간 네트워크 연결 방식을 네트워크 구성도로 작성

### 개발 기술 환경
> 개발하고자 하는 SW와 관련된 OS, DB관리 시스템, 미들웨어 등 선정 시 고려사항 기술, 오픈소스 사용 시 주의사항 제시

- OS : 시스템의 자원관리, 사용환경 제공. 가용성, 성능, 기술 지원, 주변 기기, 구축 비용 등 고려
- DB 관리 시스템 : 요구에 따른 정보생성, DB관리. 가용성, 성능, 기술지원, 상호 호환성, 구축 비용 등 고려
- WAS : 동적인 콘텐츠 처리를 위한 미들웨어. 가용성, 성능, 기술지원, 구축비용 등 고려
- 오픈소스 : 라이센스 종류, 사용자 수, 기술의 지속 가능성 등 고려

### 요구사항 유형
- 기능 : 시스템이 갖춰야할 필수적인 기능
- 비기능 : 필수 기능 외 품질이나 제약사항 관련
- 사용자 : 사용자 관점) 시스템이 제공해야 할 요구사항
- 시스템 : 개발자 관점) 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항

### 요구사항 개발 프로세스
- 도출 : 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스 기법 이용
- 분석 : 불명확, 모호한 부분 발견 및 필터링. 비용과 일정에 대한 제약 설정, 타당성 조사
  - 요구사항 분류 : 명확한 확인을 위한 요구사항 분류
  - 개념 모델링 : 쉬운 이해를 위해 상황 단순화 및 개념적으로 표현. 유스케이스 다이어그램, 데이터 흐름 모델, 상태 모델, 목표기반 모델, 사용자 인터액션, 객체 모델, 데이터 모델 등
  - 요구사항 할당 : 요구사항 만족을 위한 구성 요소 식별
  - 요구사항 협상 : 요구사항 충돌 시 해결
  - 정형 분석 : 정형화된 언어를 이용해 요구사항을 수학적 기호로 표현
- 명세 : 체계적 분석 후 승인 가능하도록 문서화
- 확인 : 명세서의 정확성 완전성 검토
  - 요구사항 검토 : 문서화된 요구사항 확인
  - 프로토타이핑 : 초기 도출된 요구사항을 토대로 프로토타입 제작 후 지속적인 업데이트
  - 모델 검증 : 분석단계에서 개발된 모델의 요구사항 충족여부 검증
  - 인수 테스트 : 실제 환경에서 요구사항들이 모두 충족되느니 사용자 입장에서 확인

#### 자료 흐름도(Data Flow Diagram)
> 요구사항 분석에서 자료의 흐름 및 변환과정과 기능을 도형 중심으로 기술하는 방법

- 프로세스 : 자료를 변환시키는 시스템의 한 부분. 처리, 기능, 변환, 버블 이라고 하며 원, 둥근 사각형으로 표시하며 프로세스 이름 기입
- 자료 흐름 : 자료의 이동, 연관 관계 표시. 화살표 위에 자료의 이름 기입
- 자료 저장소 : 시스템에서의 자료 저장소 나타냄. 도형 안에서 자료 저장소 이름 기입
- 단말 : 시스템과 교신하는 외부 개체. 도형 안에 이름 기입

### UML(Unified Modeling Language)
> 시스템 개발 과정(분석, 설계, 구현)에서 시스템 개발자와 고객 또는 개발자 상호 간 의사소통이 원할하게 이루어 지도록 표준화한 대표적인 객체지향 모델링 언어로 아래 3가지로 구성

- 사물 : 관계가 형성될 수 있는 대상들
  - 구조사물 : 시스템의 개념적, 물리적 요소표현
  - 행동사물 : 시공간에 따른 요소들의 행위 표현
  - 그룹사물 : 요소들을 그룹으로 묶어 표현
  - 주해사물 : 부가설명이나 제약조건 표현
- 관계 : 사물과 사물 사이의 연관성을 표현하는 것
  - 연관, 집합, 포함(포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 집합의 특수한 형태), 일반화, 의존(필요에 의해 짧은 시간만 연관), 실체화
- 다이어그램 : 사물과 관계를 도형으로 표현한 것
  - 정적 모델링 : 구조적 다이어그램 사용
  - 동적 모델링 : 행위 다이어그램 사용

#### 구조적 다이어그램
##### 클래스 다이어그램 : 클래스와 클래스가 가지는 속성, 클래스 사이의 관계 표현(정적 모델링의 대표)
- 클래스 : 각 개체들이 갖는 속성과 동작표현. 이름/속성(클래스의 상태나 정보 표현)/동작(함수)
- 제약조건
- 관계 : 클래스 간 연관성 표현

##### 객체 다이어그램 : 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
##### 컴포넌트 다이어그램 : 컴포넌트 간 관계, 인터페이스 표현
##### 배치 다이어그램 : 물리적 요소들의 위치 표현(결과물, 프로세스, 컴포넌트 등)
##### 복합체 구조 다이어그램 : 복합 구조를 갖는 경우 내부 구조 표현
##### 패키지 다이어그램 : 유스케이스나 클래스등의 모델 요소들을 그룹화한 패키지들의 관계 표현

#### 행위 다이어그램 (시퀀스, 커뮤니케이션, 상태, 유스케이스, 활동)
> 행위 다이어그램에는 동적 모델링인 시퀀스 다이어그램, 커뮤니케이션 다이어그램, 상태 다이어그램, 기능 모델링인 유스케이스(Use Case) 다이어 그램, 활동(Activity) 다이어그램 등이 있다.

##### 시퀀스 다이어그램
- 시스템,객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호 작용하는 과정 표현
- 액터 : 시스템으로부터 서비스를 요청하는 외부요소(사람 or 외부 시스템)
- 객체 : 메시지를 주고받는 주체로 `;`을 기준으로 앞-객체명, 뒤-클래스명 기술
- 라이프라인 : 객체가 메모리에 존재하는 기간(객체 아래 점선 그어 표현)
- 활성 상자 : 객체가 메시지를 주고받으며 구동되고 있음을 라이프라인 상에 겹쳐 직사각형 형태로 표현
- 메시지 : 객체 간 주고받음
- 객체 소멸 : 라이프라인 상 소멸 표시를 만나면 해당 객체는 더 이상 메모리에 존재하지 않음을 의미
- 프레임 : 다이어그램의 전체 또는 일부를 묶어 표현

##### 커뮤니케이션 다이어그램
- 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하나, 객체들 간 연관까지 표현
- 액터, 객체
- 링크 : 객체들 간 관계 표현, 액터와 객체, 객체 간 실선으로 표현

##### 상태 다이어그램
- 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는 지 표현
- 상태 : 객체의 상태를 둥근 사각형 안에 기술. **●**-시작상태, **⊙**-종료상태
- 이벤트 : 조건, 외부신호, 시간 등 상태에 변화를 주는 현상
- 상태 전환 : 상태 사이의 흐름, 변화 화살표로 표현
- 프레임 : 상태 다이어그램의 범위 표현

##### 유스케이스 다이어그램
- 사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현
- 시스템 범위 : 내부/외부 구분을 위해 시스템 내부의 유스케에스들을 사각형으로 묶어 시스템의 범위 표현
- 액터 : 시스템과 상호작용 하는 모든 외부 요소
- 유스케이스 : 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능
- 관계 : 액터와 유스케이스, 유스케이스와 유스케이스. 포함 관계, 확정 관계, 일반화 관계

##### 활동 다이어그램
- 자료흐름도와 유사, 사용자 관점ㅇ에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현
- 액티비티 : 액션(더 이상 분해할 수 없는 단일 작업)으로 분리될 수 있는 작업
- 노드 : 시작 노드, 종료 노드, 조건(판단) 노드 : 조건에 따라 제어의 흐름 분리, 포그(Fork)노드 : 액티비티 흐름이 분리되어 수행됨, 조인(Join)노드 : 분리되어 수행되던 앧티비티 흐름이 다시 합쳐짐
- 스윔레인 : 액티비티 수행을 담당하는 주체를 구문

# 데이터 입출력 구현
> 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화해 체계적으로 표현한 개념적 모형

## 데이터 모델
### 구성 요소
  - 개체 : DB에 표현하려는 것, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
  - 속성 : 데이터의 가장 작은 논리적 단위. 파일 구조상 데이터 항목 또는 데이터 필드
  - 관계 : 개체 간 관계, 속성 간 논리적인 연결

### 종류
#### 개념적 데이터 모델
  : 현실 세계에 대한 인가의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
#### 논리적 데이터 모델
  : 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리하도록 컴퓨터 세계의 환경에 맞춰 변환하는 과정
#### 물리적 데이터 모델
  : 실제 컴퓨터에 데이터가 저장되는 방법을 정의하는 물리 DB설계 과정

#### 데이터 모델에 표시할 요소
- 구조 : 논리적으로 표현된 개체 타입들 간 관계로 데이터 구조 및 정적 성질 표현
- 연산 : DB에 저장된 실제 데이터를 처리하는 작업에 대한 명세. DB를 조작하는 기본 도구
- 제약 조건 : 저장될 수 있는 실제 데이터의 논리적인 제약 조건

## 이상(Anomaly)
- 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복발생 및 이로 인한 테이블 조작 시 문제 발생
### 이상의 종류
- 삽입 이상 : 테이블에 데이터를 삽입 시 원하지 않은 값들로 인해 삽입 불가능
- 삭제 이상 : 테이블 내 한 튜플 삭제 시 상관없는 값들도 함께 삭제(연쇄 삭제) 발생
- 갱신 이상 : 테이블 내 튜플에 있는 속성값 갱신 시 일부 튜플의 정보만 갱신되어 정보에 불일치성 발생

### 함수적 종속
> 어떤 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라 할 때 속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을때 Y는 X에 함수적 종속 또는 X가 Y를 함수적으로 결정한다고 하고, X → Y로 표기한다. X → Y의 관계를 갖는 속성 X와 Y에서 X를 결정자 (Determinant)라 하고, Y를 종속자(Dependent)라고 한다.

- 완전 함수적 종속 : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 어떠한 진부분 집합 Z(즉, Z ⊂ X)에도 함수적 종속이 아닐 때 속성 Y는 속성 집합 X에 완전 함수적 종속이라고 함
- 부분 함수적 종속 : 부분 함수적 종속 : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 임의의 진부분 집합에 대해 함수적 종속일 때, 속성 Y는 속성 집합 X에 부분 함수적 종속이라고 함

### 정규화(Normalization)
> 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용해 테이블을 무손실 분해하는 과정

- 정규화 과정

![image](https://user-images.githubusercontent.com/81230679/135783528-5409a403-327c-493a-944d-c76258cf0c32.png)

※ 이행적 함수족 종속 : A → B이고 B → C일 때 A → C 를 만족하는 관계를 이행적 함수적 종속이라고 함

### 반정규화(Denormalization)
> 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정. 의도적으로 정규화 원칙을 위배하는 행위

- 테이블 통합 : 두 개의 테이블이 Join되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움될 경우 수행
- 테이블 분할
  - 수평 분할 : 레코드를 기준으로 테이블을 분할하는 것. 레코드별 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블 분할
  - 수직 분할 : 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블 분할
- 중복 테이블 추가 : 여러 테이블에서 데이터를 추출해 사용하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가해 효율성 향상
  - 집계 테이블의 추가, 진행 테이블의 추가, 특정 부분만을 포함하는 테이블의 추가 등의 방법 사용
- 중복 속성 추가 : Join해서 데이터를 처리할 때 테이터 조회 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가

### 논리 데이터 모델의 물리 데이터 모델로 변환
- 엔티티를 테이블로 변환 : 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환
- 슈퍼타입 기준 테이블 변환 : 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 변환
- 서브타입 기준 테이블 변환 : 슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 변환
- 개별타입 기준 테이블 변환 : 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환
- 속성을 컬럼으로 변환 : 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환
- 관계를 외래키로 변환 : 논리 데이터 모델에서 정의된 관계는 기본키와 이를 참조하는 외래키로 변환

## 인덱스
> 데이터 레코드를 빠르게 접근하기 위해 `키값`,`포인터` 쌍으로 구성되는 데이터 구조. 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식의 클러스터드 인덱스와 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식인 넌클러스터드 인덱스가 있음

- 트리 기반 인덱스 : 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것, 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용
- 비트맵 인덱스 : 인덱스 컬럼의 데이터를 Bit값인 0,1로 변환해 인덱스 키로 사용하는 방법
- 함수 기반 인덱스 : 컬럼의 값 대신 특정 함수나 수식을 적용해 산출된 값을 사용. B+ 트리 인덱스 또는 비트맵 인덱스를 생성해 사용
- 비트맵 조인 인덱스 : 다수의 조인된 객체로 구성된 인덱스. 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다름
- 도메인 인덱스 : 개발자가 필요한 인덱스를 직접 만들어 사용하는 것. 확장형 인덱스 라고도 함

## 뷰(View)
> 접근이 허용된 자료만 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블. 저장 장치 내에 물리적으로 존재하지 않지만, 사용자에게 있는 것처럼 간주됨. `CREATE`문으로 정의, `DROP`문으로 제거. 데이터의 논리적 독립성을 제공

## 트랜잭션(Transaction)
> DB의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위. 한꺼번에 모두 수행되어야 할 일련의 연산들

### 트랜잭션 특징
- 원자성 : 트랜잭션의 연산은 DB에 모두 반영되도록 완료 or 전혀 반영되지 않도록 복구 되어야함
- 일관성 : 실행을 완료하면 언제나 일관성 있는 DB상태로 변환
- 독립성 : 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 서로의 연산에 끼어들 수 없음
- 지속성 : 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

## 클러스터
> 데이터 액세스 효율 향상을 위해 동일한 성격의 데이터를 동일한 데이터 블록에 물리적으로 저장
- 클러스터링 키로 지정된 컬럼 값의 순서대로 저장되고 여러 개의 테이블이 하나의 클러스터에 저장됨
- 클러스터링 된 테이블은 데이터 조회 속도는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하시킴
- 처리 범위가 넓은 경우 단일 테이블 클러스터링, 조인이 많이 발생하는 경우 다중 테이블 클러스터링 사용

## 파티션
> 대용량의 테이블이나 인덱스를 작은 논리적 단위로 나누는 것

- 범위 분할 : 지정한 열의 값을 기준으로 분할
- 해시 분할 : 해시 함수를 적용한 결과 값에 따라 데이터를 분할
- 조합 분할 : 범위 분할로 분할한 다음 해시 함수를 적용해 다시 분할
- 인덱스 파티션 : 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것

### 데이터 베이스 용량 설계
- 테이블에 저장할 데이터양, 인덱스, 클러스터 등이 차지하는 공간 등을 예측,반영 해야 함
- DB용량을 정확히 산정해 디스크의 저장 공간을 효과적으로 사용, 확장성 및 가용성을 높임
#### 데이터 접근성을 향상시키는 설계 방법
- 테이블의 테이블스페이스와 인덱스의 테이블스페이스를 분리해 구성
- 테이블스헤이스와 임시 테이블스페이스를 분리해 구성
- 테이블을 마스터 테이블과 트랜잭션 테이블로 분류

# 통합구현
> 사용자의 요구사항에 맞춰 송.수신 모듈과 중계모듈 간 연계를 구현하는 것. 일반적인 통합 구현은 송.수신 시스템과 모듈, 중계 시스템, 연계 데이터, 네트워크로 구성

- 송신 시스템과 모듈 : 데이터를 생성 및 변환해 전송, 송신 모듈과 모니터링 기능으로 구분. 모니터링 기능은 전송 데이터의 생성~송신까지의 과정과 송신 상태 등 확인
- 수신 시스템과 모듈 : 수신 받은 데이터를 정제 및 변환, 수신 모듈과 모니터링 기능으로 구분. 수신 데이터를 정제, 애플리케이션이나 DB 테이블에 적합한 데이터로 변환
- 중계 시스템 : 내.외부 시스템 간 또는 내부 시스템 간 연계 시 사용되는 아키텍쳐
- 연계 데이터 : 송.수신 되는 데이터. 속성, 길이, 타입 등이 포함
- 네트워크 : 송.수신 시스템, 중계 시스템을 연결해주는 통신망

## 연계 요구사항 분석
> 통합 구현을 위해 사용자 요구사항을 분석하고 연계 데이터를 식별 및 표준화 해 연계 데이터를 정의하는 것

### 연계 요구사항 분석 절차

1. 시스템 구성도, 응용 애플리케이션 구성 등을 통해 송.수신 시스템의 H/W, S/W구성, 네트워크 현황 확인
  - 시스템 구성도 : 송.수신 시스템의 H/W, S/W, 네트워크 구성 등을 정의한 문서
  - 응용 애플리케이션 구성 : 메뉴 구조, 화면 설계, 데이터의 발생 시점, 발생 유형, 발생 주기 등을 정의한 문서
2. 송.수신 시스템과 연결할 데이터와 관련된 테이블 정의서, 코드 정의서 등의 문서 확인
  - 테이블 정의서 : 테이블에서 관리되는 컬럼들의 특징, 인덱스, 업무 규칙 등을 정의한 문서
  - 코드 정의서 : DB에서 코드성 속성을 정의한 문서
3. 확인된 시스템의 구성과 데이터 현황 정보 등을 기반으로 체크리스트 작성
4. 시스템 구성도, 응용 애플리케이션 구성, 테입르 정의서, 코드 정의서, 체크리스트 등을 사용자, 시스템 관리자 등과 공유 및 인터뷰, 설문조사 실시
5. 인터뷰나 설문조사를 통해 확인된 결과를 기반으로 요구사항의 ID, 이름, 유형, 설명, 해결 방안 등이 포함된 연계 요구사항 분석서 작성

## 연계 데이터 식별 및 표준화
> 연계 데이터를 구성하기 위해 연계 데이터를 식별하고 식별된 연계 데이터를 표준화 한 후 이를 기반으로 연계(인터페이스) 정의서 작성

### 연계 데이터 식별 및 효준화 절차
1. 연계 범위 및 항목 정의 : 데이터 타입, 길이, 코드화 여부 등 시스템 간 연계할 정보 상세화
2. 연계 코드 변환 및 매핑 : 정보로 전환 OR 검색 조건으로 활용하기 위해 연계 정보 중 코드로 관리되어야 할 항목 변환
3. 연계 데이터 식별자와 변경 구분 추가 : 수신 시스템의 연계 정보에 송신 시스템의 식별자, 추가, 수정, 삭제 중 어떤 조작을 수행하는지 식별해주는 구분 정보 추가, 연계 데이터의 확인 및 모니터링을 위해 인터페이스 테이블 또는 파일에 관리 정보 추가
4. 연계 데이터 표현 방법 정의 : 연계 대상 범위 및 항목과 코드 변환 및 매핑 방식을 정의한 후에는 연계 데이터 구성
5. 연계 정의서 및 명세서 작성
  - 연계 정의서는 송.수신 시스템에서 연계할 항목과 연계 데이터의 타입, 길이 등을 구성하고 형식을 정의한 결과를 기반으로 작성
  - 연계 정의서에는 송.수신 시스템의 시스템명과 인터페이스ID, 인터페이스 방식 및 주기 등 송.수신 시스템 간 인터페이스 현황을 기재
  - 연계 명세서는 연계 정의서에 작성한 인터페이스 ID별로 인터페이스 주기 및 방식, DB및 파일 형식, 송.수신 시스템의 타입, 길이, 식별자, 코드화 여부 등 세부사항 작성

### 연계 메커니즘 
- 데이터의 생성 및 전송을 담당하는 송신 체계와 데이터 수신 및 운영 DB반영을 담당하는 수신 체계로 구성
- 송신 시스템은 운영 DB로부터 인터페이스 테이블이나 파일(xml, text, csv등) 형식으로 연계 데이터를 생성해 송신
- 수신 시스템은 송신 시스템으로부터 전송된 데이터를 받아 수신 시스템에 맞는 데이터로 변환 후 운영 DB에 반영
- 송.수신 시스템 사이에는 데이터의 송.수신과 송.수신 시스템 현황을 모니터링 하는 중계 시스템을 설치할 수 있음
- 송.수신 시스템과 중계 시스템은 제각기 역하이 중복되지 않도록 아키텍쳐 설계 후 인터페이스 테스트와 통합 테스트를통해 기능 검증
- 연계 메커니즘의 연계 방식에는 직접 연계 방식과 간접 연계 방식이 있음

#### 연계 메커니즘의 직접 연계 방식
> 중간 매개체 없이 송.수신 시스템이 직접 연계하는 방식

![image](https://user-images.githubusercontent.com/81230679/135844613-488d1b41-8c2f-4501-b616-dd372e19df00.png)

- DB Link : DB에서 제공하는 DB Link객체를 이용하는 방식
- API : 데이터를 송신 시스템의 DB에서 읽어와 제공하는 애플리케이션 프로그래밍 인터페이스
  - API : 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 응용프로그램 개발 시 이용할 수 있도록 정의해 놓은 인터페이스
  - Open API : API기능을 누구나 무료로 사용해 프로그램을 개발하거나 새로운 API를 추가할 수 있도록 공개된 API
- DB Connection : 수신 시스템의 WAS에서 송신 시스템의 DB로 연결해주는 방식
- JDBC : Java에서 DB에 접근해 데이터를 삽입, 삭제, 수정, 조회할 수 있도록 Java, DB를 연결해주는 방식

#### 연게 메커니즘의 간접 연계 방식
> 송.수신 시스템 사이에 중간 매개체를 두어 연계하는 방식

![image](https://user-images.githubusercontent.com/81230679/135845294-34f5b03d-e986-4398-903f-00a3eb9840de.png)

- 연계 솔루션 : EAI(송.수신 처리 및 진행 현황 모니터링 및 통제 시스템)서버와 송.수신 시스템에 설치되는 클라이언트를 이용하는 방식
- ESB : 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 방식
- Socket : 서버는 통신을 위한 소켓을 생성해 포트할당, 클라이언트의 통신 요청 시 클라이언트와 연결해 통신하는 네트워크 기술
- Web Service : 웹 서비스에서 WSDL과 UDDI, SOAP 프로토콜을 이용해 연계하는 방식

#### 연계 메커니즘의 구성

![image](https://user-images.githubusercontent.com/81230679/135845685-44df49ad-eaee-4165-8d8b-fbd454a834d7.png)

#### 연계 메커니즘 구간별 장애 및 오류 모니터링 현황

<img width="477" alt="스크린샷 2021-10-05 오후 7 05 18" src="https://user-images.githubusercontent.com/81230679/136003147-f053d04a-8585-4905-ba07-6cfb8a3534d5.png">

#### 연계 데이터 보안
> 송신시스템에서 수신 시스템으로 전송되는 연계 데이터는 보안에 취약할 수 있으므로 데이터의 중요성을 고려해 보안을 적용해야 함. 일반적으로 연계 데이터의 보안은 전송 구간에서의 암.복호화로 구현

- 전송 구간 보안 : 전송되는 데이터나 패킷을 쉽게 가로챌 수 없도록 암호화 기능이 포함된 프로토콜 사용, 내용을 확인할 수 없게 데이터나 패킷 암호화
- 데이터 보안 : 송신 시스템에서 연계 데이터 추출 시 수신 시스템에서 데이터 운영 DB에 반영 시 데이터를 암.복호화, 데이터 보안을 위해 암.복호화 적용 대상 선정, 암호화 알고리즘, 암.복호화 적용을 위한 환경 설정을 설계 및 구현(암.복호화 적용 대상은 연계 데이터의 중요도에 따라 선정)

#### 연계 모듈의 구현 환경
> 연계 메커니즘에 다라 구현된 연계 시스템 환경 및 모듈 구현 환경. 트리거 또는 프로그래밍 언어를 이용한 EAI, ESB 방식과, 배치 프로그램 및 인터페이스 파일을 이용한 웹 서비스 방식으로 구분

- EAI : 기업 내 애플리케이션 및 플랫폼 간 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
  - Point-to-Point : 가장 기본적인 애플리케이션 통합 방식으로, 애플리케이션을 1 : 1로 연결
  - Hub & Spoke : 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
  - Message Bus(ESB 방식) : 애플리케이션 사이 에 미들웨어를 두어 처리하는 방식
  - Bus Hybrid : Hub & Spoke와 Message Bus 의혼합방식
- ESB : 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션. EAI와 유사하나 애플리케이션 보다는 서비스 중심의 통합 지향
- 웹 서비스 : 네트워크의 정보를 표준화된 서비스 형태로 만들어 공유하는 기술. 서비스 지향 아키텍쳐 (SOA)개념을 실현하는 대표적인 기술
  - SOAP(Simple Object Access Protocol) : HTTP, HTTPS, SMTP 등을 화용해 XML기반의 메시지를 네트워크 상에서 교환하는 프로토콜
  - UDD(Universial Description, Discovery and Intergration) : WSDL을 등록해 서비스와 서비스 제공자를 검색하고 접근하는데 사용됨
  - WSDL(Web Services Description Language) : 웹 서비스명, 서비스 제공 위치, 프로토콜 등 웹 서비스에 대한 상세 정보를 XML형식으로 구현

#### 연계 테스트
> 구축된 연계 시스템과 연계 시스템의 구성 요소가 정상적으로 동작하는지 확인하는 활동

1. 연계 테스트 케이스 작성 : 
2. 연계 테스트 환경 구축 : 
3. 연계 테스트 수행 : 
4. 연계 테스트 수행 결과 검증 : 

### XML(eXtensible Markup Language)
> 웹브라우저 간 HTML문법이 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위해 개발된 다목적 마크업 언어. 유니코드 기반의 다국어 지원. 사용자 태그 정의 가능, 다른 사용자가 정의한 태그 사용 가능

```xml
 <!-- XML의 첫 문단 -->
<?xml version="버전" encoding="언어셋" standalone ="yes|no"?>
<!-- XML 요소(Element)의 구성 -->
<요소이름 속성1="속성값1" 속성 2="속성값2"... > 내용 </요소 이름>
```

### JSON(JavaScript Object Notation)
> 송석-값 쌍으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷. 비동기 처리에 사용되는 AJAX에서 XML을 대체해 사용

# 서버 프로그램 구현

## 개발환경 구축
### 하드웨어 환경
> 응용 소프트웨어 개발을 위해 개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것. 사용자와의 인터페이스 역할을 하는 클라이언트, 클라리언트와 통신해 서비스를 제공하는 서버로 구성.  서버는 사용 목적에 따라 웹 서버, 웹 애플리케이션 서버, DB서버, 파일 서버 등으로 나뉨.

- 웹 서버 : 클라이언트로부터 직접 요청을 받아 처리하는 서버, 저용량의 정적파일 제공
- 웹 애플리케이션 : 사용자에게 동적 서비스 제공을 위해 웹 서버로부터 요청을 받아 데이터 가공 작업 수행, 웹 서버와 DB 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할 수행
- DB 서버 : DB와 이를 관리하는 DBMS를 운영하는 서버
- 파일 서버 : DB에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장하는 서버

### 소프트웨어 환경
> 클라이언트와 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성. 시스템 소프트웨어는 OS, 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS등. 개발 소프트웨어는 요구사항 관리 도구, 설계/모델링 도구, 구현 도구, 빌드 도구, 테스트 도구, 형상 관리 도구 등.

- 요구사항 관리 도구 : 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 S/W
- 설계/모델링 도구 : UML(통합 모델링 언어)을 지원, 개발의 전 과정에서 설계 및 모델링을 도와주는 S/W
- 구현 도구 : 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어
- 빌드 도구 : 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 S/W
- 테스트 도구 : 코듈들이 요구사항에 적합하게 구현되었는지 테스트하는 S/W
- 형상 관리 도구 : 산출물들을 버전별로 관리해 품질 향상을 지원하는 S/W

### 모듈
> 모듈화 : 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 분해하는 것. 모듈 간 결합도는 최소화 응집도는 최대화가 목표


-  모듈화를 통해 분리된 시스템의 각 기능들로 서브루틴, 서스시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용됨
-  모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독림됨을 의미하는 것, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호 작용을 배제함으로써 이루어짐
-  독립성이 높은 모듈일수록 모듈을 수정하더라도 다른 모듈들에게는 거의 영향을 미치지 않으며, 오류가 발생해도 쉽게 발견하고 해결할 수 있음
-  모듈의 독립성은 결합도와 응집도에 의해 측정되며, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 함

#### 결합도(Coupling)
> 모듈 간 상호 의존하는 정도 또는 두 모듈 사이 연관 관계

- 다양한 결합으로 모듈구성 가능하나 결합도가 약할수록 품질이 높음
- 결합도가 강하면 시스템 구현 및 유지보수가 어려움


<img width="416" alt="스크린샷 2021-10-07 오후 12 21 11" src="https://user-images.githubusercontent.com/81230679/136315265-e1949015-7540-4381-b4d6-1b4177aa10b6.png">

#### 응집도
> 정보 은닉 개념의 확장. 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도. 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미

- 다양한 기준으로 모듈을 구성할 수 있으나 응집도가 강할수록 품질이 높음

<img width="407" alt="image" src="https://user-images.githubusercontent.com/81230679/136315508-fadf25af-0f8b-4c4f-8c2d-a7aedea2b31d.png">

<img width="404" alt="image" src="https://user-images.githubusercontent.com/81230679/136315574-e617e615-d90b-415d-ad23-29fda9abe688.png">

### Fan-In / Fan-Out
> 팬인 : 어떤 모듈을 제어(호출)하는 모듈의 수 / 팬아웃 : 어떤 모듈에 의해 제어(호출)되는 모듈의 수

- 팬인, 팬아웃 분석해 시스템의 복잡도 확인.
- 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있으나, 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트 필요

<img width="421" alt="image" src="https://user-images.githubusercontent.com/81230679/136315765-9e80369f-c7d6-49a3-a906-8df00888f580.png">

### 공통 모듈
> 여러 프로그램에서 공통적으로 사용할 수 있는 모듈. 자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능들이 공통모듈로 구성.

- 공통 모듈을 구현할 때는 다른 개발자들이 해당 기능을 명확히 이해할 수 있도록 명세기법 준수 해야 함
  - 정확성 : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성
  - 명확성 : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확히 작성
  - 완전성 : 시스템 구현을 위해 필요한 모든 것을 기술
  - 일관성 : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
  - 추적성 : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악하도록 작성

## 재사용
> 비용과 개발 시간 절약을 위해 이미 개발된 기능들 파악, 재구성해 새로운 시스템 또는 기능 개발에 사용하기 적합하도록 최적화 시키는 작업

- 재사용되는 대상은 외부 모듈과의 결합도는 낮고, 응집도는 높아야 함
- 재사용 규모에 따른 분류
  - 함수와 객체 : 클래스나 메소드 단위의 소스 코드를 재사용
  - 컴포넌트 : 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용
  - 애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용

### DBMS 접속
> 사용자가 데이터 사용을 위해 응용 시스템을 이용해 DBMS에 접근 하는 것

- 응용 시스템은 사용자로부터 매개 변수를 전달받아 SQL을 실행하고 DBMS로부터 전달받은 결과를 사용자에게 전달하는 매개체 역할을 수행
- 인터넷을 통해 구동되는 웹 응용 프로그램은 웹 응용 시스템을 통해 DBMS에 접근
- DBMS 접속 기술 : DBMS에 접근하기 위해 사용하는 API또는 API의 사용을 편리하게 도와주는 프레임워크
####  프레임워크
> 특정 기능을 수행하기 위해 필요한 클래스나 인터페이스 등을 모아둔 집합체

<img width="409" alt="image" src="https://user-images.githubusercontent.com/81230679/136320078-e1b0af7e-6b41-4e65-9a9f-1d39153594a7.png">

- JDBC : Java로 다양한 종류의 DB에 접속, SQL문 수행 시 사용되는 표준 API
- ODBC : DB에 접근하기 위한 표준 개방형 API, 개발 언어에 관계없이 사용할 수 있음
- MyBatis : JDBC 코드를 단순화해 사용할 수 있는 SQL Mapping기반 오픈 소스 프레임워크. SQL을 거의 그대로 사용할 수 있어 SQL친화적인 국내 환경에 적합해 많이 사용됨
  - 동적 SQL(Dynamic SQL) : 다양한 조건에 따라 SQL 구문을 동적으로 변경해 처리할 수 있는 SQL 처리 방식. 사용자로부터 SQL문의 일부 또는 전부를 입력받아 실행할 수 있으며, 정적 SQL에 비해 속도가 느리지만, 상 황에  따라  다양한  조건을  첨가하는  등  유연한  개발 이 가능
  - 정적 SQL :  SQL코드를 변수에 담지 않고 코드 사이에 직접 기술한 SQL문

### 서버개발
> 웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작해 웹 애플리케이션 서버에 탑재하는 것

- 웹 애플리케이션 서버에 구현된 서버 프로그램은 웹 서버로부터 받은 요청을 처리해 결과를 반환하는 역할 수행
- 서버 개발에 사용되는 프로그래밍 언어네느 Java, JS, Python, PHP, Ruby 등이 있음
- 객 프로그래밍 언어에는 해당 언어로 서버 프로그램을 개발할 수 있도록 지원하는 프레임워크가 있음

<img width="410" alt="image" src="https://user-images.githubusercontent.com/81230679/136319774-0e440d68-62b4-4f05-b2d4-d5c93da617ac.png">

### 서버 개발 과정
- 서버  개발은  DTO/VO,  SQL,  DAO,  Service, Controller를 각각 구현하는 과정을 통해 이루어짐.
- 구현 순서는 개발자가 임의 변경 가능
- 개발하려는 서버 프로그램의 목적, 개발 언어, 규모 등의 이유로 총합 or 세분화 가능
- 모든 과정에서 보안 약점이 발생하지 않도록 소프트웨어 개발 보안 가이드 참고

<img width="409" alt="스크린샷 2021-10-07 오후 1 25 20" src="https://user-images.githubusercontent.com/81230679/136320236-955e2daf-5186-42ea-b0ee-6940970ae2f0.png">

<img width="406" alt="image" src="https://user-images.githubusercontent.com/81230679/136320273-c70538dd-1d22-4f17-b66f-ec83d6dfcd49.png">

### 배치 프로그램(Batch Program)
> 사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것을 의미

- 배치 프로그램이 자동으로 수행되는 주기에 따라 정기 배치, 이벤트성 배치, On-Demand 배치로 구문
- 필수 요소 : 대용량 데이터, 자동화, 견고성, 안정성/신뢰성, 성능
- 배치 스케줄러 : 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구

<img width="407" alt="image" src="https://user-images.githubusercontent.com/81230679/136320448-813fae80-0f74-45ce-a55a-8ac2ce1161f7.png">

# 화면 설계

## 사용자 인터페이스
> 사용자와 시스템 간 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어

- CLI(Command Line Interface) : 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스
- GUI(Graphical User Interface) : 아이콘이나 메뉴를 마우스로 선택해 작업을 수행하는 그래픽 환경의 인터페이스
- NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스

### 사용자 인터페이스 기본 원칙
- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함
- 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함
- 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 함
- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화 해야 함

### 사용자 인터페이스 설계 지침
- 사용자 중심 : 사용자가 쉽게 이해하고 편리하게 사용할 수 있는 환경 제공, 실사용자에 대한 이해가 바탕이 되어야 함
- 일관성 : 버튼이나 조작 방법등을 일관성 있게 제공해 사용자가 쉽게 기억하고 습득할 수 있게 설계
- 단순성 : 조작 방법을 단순화시켜 인지적 부담을 감소
- 결과 예측 가능 : 작동시킬 기능만 보고도 결과를 미리 예측할 수 있게 설계
- 가시성 : 메인 화면에 주요 기능을 노출시켜 최대한 조작이 쉽도록 설계
- 표준화 : 기능 구조와 디자인을 표준화해 한 번 학습한 이 후에는 쉽게 사용할 수 있도록 설게
- 접근성 : 사용자의 연력, 성별, 인종 등 다양한 계층이 사용할 수 있도록 설계
- 명확성 : 사용자가 개념적으로 쉽게 인지할 수 있도록 설계
- 오류 발생 해결 : 오규라 발생하면 사용자가 쉽게 인지할 수 있도록 설계

### UI 설계 도구
- 와이어프레임 : 기획 단계의 초기에 제작, 페이지에 대한 개략적인 레이아웃이나 UI요소 등에 대한 뼈대 설계. 각 페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계
- 목업 : 디자인, 사용 방법 설명, 평가 등을 위해 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 모형. 시각적으로만 구성 요소를 배치하는 것(실제 구현X)
- 스토리보드 : 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 추가. 상단이나 우측에는 제목, 작성자, 좌측에는 UI화면, 우측에는 디스크립션 기입
- 프로토타입 : 와이어프레임이나 스토리보드에 인터랙션 적용해 실제 구현된 것 처럼 테스트가 가능한 동적인 모형. 사용성 테스트나 작업자 간 서비스 이해를 위해 작성하는 샘플
  - 페이퍼 프로토타입 : 아날로그적 방법, 스케치, 그림, 글 등을 이용해 손으로 직접 작성하는 방법
  - 디지털 프로토타입 : 파워포인트, 아크로뱃, 비지오, 옴니그래플 등과 같은 프로그램을 사용해 작성하는 방법
- 유스케이스 : 사용자 측면에서의 요구사항, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술. 사용자의 요구사항을 빠르게 파악함으로써 프로젝트 초기에 시스템의 기능적인요구를 결정하고 그 결과를 문서화

### UI 스타일 가이드 작성
> 개발자나 디자이너들이 UI를 작성할 때 기준이 되는 규칙들, 구동 환경, 레이아웃, 네비게이션 등을 정의

- 구동 환경 정의 : 컴퓨터 OS, 웹 브라우저, 모니터 해상도, 프레임 세트 등을 사용 환경에 적합하도록 규정하는 단계
- 레이아웃 정의 : 화면 구조를 정의하고 각 영역의 메뉴를 구성하는 단계. Top, Left, Contents, Footer Area가 있으며, 기본적으로 Top, Left, Contents영역으로 구성
  - Top : 필수 영역으로 시스템 전체 페이지에 동일하게 적용
  - Left : 선택 영역으로 시스템별 서브 페이지에 선택적으로 적용
  - Contents : 필수 영역으로 시스템의 전체 콘셉트를 나타내는 메인 이미지와 시스템별 필요한 콘텐츠를 표시
  - Footer : 선택 영역으로 회사 상황에 따라 표시 여부 결정
- 네비게이션 정의 : 메뉴타입을 선택해 적용하는 단계. 사용자가 원하는 정보를 빠르게 찾을 수 있도록 안내하는 것. 메뉴, 버튼, 링크 등으로 구성
- 기능 정의 : 시스템에 적용할 업무 과정에서 일어나는 모든 활동이나 필요한 데이터 간 관계 등을 논리적인 모델로 상세화 하는 단계
- 구성 요소 정의 : 화면에 표시할 그리드나 버튼 등을 정의하는 단계

## UI 요구사항 확인
> 새로 개발할 시스템에 적용할 UI 관련 요구사항을 조사해 작성하는 단계

<img width="454" alt="image" src="https://user-images.githubusercontent.com/81230679/136328035-24513235-23f0-4f3f-ade6-86c64db5ebba.png">

### UI 흐름 설계
> 업무의 진행 과정이나 수행 절차에 따른 흐름을 파악해 화면과 폼을 설계하는 단계

- 기능 작성 : 화면에 표현할 기능을 작성하는 단계
- 입력 요소 확인 : 화면에 표현되어야 할 기능을 확인한 후 화면에 입력할 요소를 확인하는 단계
- 유스케이스 설계 : UI 요구사항 기반으로 UI 유스케이스 설계 단계. 화면에 표현할 입력 요소들의 형태나 입력 방법, 배치 등을 고려해 설계
- 기능 및 양식 확인 : 분석한 기능을 토대로 텍스트 박스, 콤보 박스, 라디오 박스, 체크 박스 등을 확인하고 규칙 정의

### UI 상세 설계
> 실제 설계 및 구현을 위해 모든 화면에 대해 자세한 설계 진행하는 단계

<img width="445" alt="image" src="https://user-images.githubusercontent.com/81230679/136328492-f4f02b50-99fa-4d18-a364-5049b0c04a9b.png">

# 애플리케이션 테스트 관리

## 애플리케이션 테스트
> 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차. 개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인하고 소프트웨어가 기능을 정확히 수행하는지 검증

### 애플리케이션 테스트의 기본 원리
- 완벽한 테스트 불가능 : 애플리케이션 테스트는 소프트웨어의 잠재적인 결함을 줄일 수 있지만 결함이 없다고 증명할 수는 없음.
- 결함 집중 : 애플리케이션의 결함은 대부분 개발자의 특성이나 애플리케이션의 기능적 특징 때문에 특정 모듈에 집중되어 있으며, 애플리케이션의 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다고 하여 파레토 법칙을 적용하기도 함
- 살충제 패러독스 : 애플리케이션 테스트에서는 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 살충제 패러독스 현상이 발생하며 살충제 패러독스를 방지하기 위해 테스트 케이스를 지속적으로 보완 및 개선 해야 함
- 테스팅은 정황 의존 : 소프트웨어 특징, 테스트 환경, 테스터 역량 등 정황에 따라 테스트 결과가 달라질 수 있으므로 정황에 따라 테스트를 다르게 수행해야 함
- 오류-부재의 궤변 : 소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 ㅎ말할 수 없음을 의미

### 애플리케이션 테스트의 분류
- 프로그램 실행 여부에 따른 테스트
  - 정적 테스트 : 프로그램 실행하지 않고 명세서나 소스코드를 대상으로 분석
  - 동적 테스트 : 프로그램을 실행해 오류를 찾는 테스트. S/W 개발 모든 단계에서 테스트 수행 가능
- 테스트 기반에 따른 테스트
  - 명세 기반 테스트 : 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트
  - 구조 기반 테스트 : S/W 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트
  - 경험 기반 테스트 : 유사 S/W나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트
- 시각에 따른 테스트
  - 검증 테스트 : 개발자의 시각에서 제품의 생산 과정을 테스트하는 것으로, 제품이 명세서대로 완성 됐는지를 테스트함
  - 확인 테스트 : 사용자의 시각에서 생산된 제품의 결과를 테스트하는 것으로, 사용자가 요구한대로 제품이 완성됐는지, 제품이 정상적으로 동작하는지를 테스트함
- 목적에 따른 테스트
  - 회복 테스트 : 시스템에 여러가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지 확인
  - 안전 테스트 : 시스템에 설치된 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지 확인
  - 강도 테스트 : 시스템에 과도한 정보량이나 빈도 등을 부과해 과부하 시에도 S/W가 정상적으로 실행되는지 확인
  - 성능 테스트 : S/W의 실시간 성능이나 전체적인 효율성을 진단하는 테스트. 응답시간, 처리량 등을 테스트
  - 구조 테스트 : S/W 내부의 논리적인 경로, 소스코드의 복잡도 등을 평가하느 테스트
  - 회귀 테스트 : S/W의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
  - 병행 테스트 : 변경된 S/W와 기존 S/W에 동일한 데이터를 입력해 결과 비교하는 테스트

### 화이트박스 테스트
> 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트해 테스트 케이스를 설계하는 방법

- 원시코드의 문장을 한 번이상 실행함으로써 수행됨. 모듈 안의 작동을 직접 관찰할 수 있음

#### 화이트박스 테스트 종류
- 기초 경로 검사 : 테스트 케이스 설계자가 절차적으로 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법. 테스트 측정 결과는 실행 경로의 기초를 정의하는데 지츰으로 사용됨
- 제어 구조 검사
  - 조건검사 : 프로그램 모듈 내 논리적 조건을 테스트하는 테스트 케이스 설계 기법
  - 루프검사 : 프로그램의 반복 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
  - 데이터 흐름 검사 : 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법

#### 화이트박스 테스트 검증 기준
> 테스트 케이스들이 테스트에 얼마나 적정한지를 판단하는 기준.

- 문장 검증 기준, 분기 검증 기준, 조건 검증 기준, 분기/조건 기준 등이 있음

### 블랙박스 테스트
> S/W가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트. 기능 테스트라고도 함

- 사용자의 요구사항 명세를 보면서 테스트하는 것으로, 주로 구현된 기능을 테스트. S/W 인터페이스에서 실시되는 테스트

#### 블랙박스 테스트 종류
- 동치 분할 검사 : 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 기법
- 경계값 분석 : 입력 자료에만 치중한 동치 분할 기법을 보완하기 위한 기법으로, 입력 조건의 경계값을 테스트 케이스로 선정하여 검사함
- 원인 - 효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
- 오류 예측 검사 : 과거의 경험이나 확인자의 감각으로 테스트하는 기법
- 비교 검사 : 여러 버전의 프로글매에 동일한 테스트 자료를 제공해 동일한 결과가 출력되는지 테스트

### 개발 단게에 따른 애플리케이션 테스트
- 단위 테스트 : 코딩 직후 S/W설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것
  - 구조기반 테스트 : 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트 시행
  - 명세기반 테스트 : 목적 및 실행 코드 기반의 블랙박스 테스트 시행
- 통합 테스트 : 단위 테스트가 완료된 모듈들을 결합해 하나의 시스템으로 완성시키는 과정에서의 테스트 의미
  - 비점진적 통합 방식 : 단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트 하는 방법. 규모가 작은 S/W에서 유리하며 단시간 내에 테스트 가능
    - 빅뱅 통합 테스트 : 모듈 간 상호 인터페이스를 고려하지 않고 단위 테스트가 끝난 모듈을 한꺼번에 결합시켜 테스트 하는 방법
  - 점진적 통합 방식 : 모듈 단위로 단계적으로 통합하며 테스트하는 방법. 오류 수정이 용이, 인터페이스와 연관된 오류를 완전히 테스트할 가능성 높음
    - 하양식 통합 테스트 : 프로그 램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법
    - 상향식 통합 테스트 : 프로그 램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법
    - 혼합식 통합 테스트 : 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식으로, 샌드위치(Sandwich)식 통합 테스트 방법이라고도 함
  - 회귀 테스트 : 이미 테스트된 프로그램의 테스팅을 반복하는 것. 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인

- 시스템 테스트 : 개발된 S/W가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트
- 인수 테스트
  > 개발한 S/W가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트 하는 것

  - 알파 테스트 : 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법, 테스트는 통제된 환경에서 행해지며 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하며 기록
  - 베타 테스트 : 선정된 최종 사용자가 여러명의 사용자 앞에서 행하는 테스트 기법, 개발자에 의해 제어되지 않은 상태에서 테스트가 행해지며 발견된 오류와 사용상의 문제점을 기록하고 개발자에게 주기적으로 보고

### 애플리케이션 테스트 프로세스
> 개발된 S/W가 사용자의 요구대로 만들어졌는지, 결함은 없는지 등을 테스트하는 절차

![image](https://user-images.githubusercontent.com/81230679/136399539-cb1d9932-a2f2-4043-ada3-01e4a5665d19.png)


### 테스트 케이스
> 구현된 S/W가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서로 명세 기반 테스트의 설계 산출물에 해당

![image](https://user-images.githubusercontent.com/81230679/136402356-8b925439-8703-44ae-a338-772d31f7848a.png)

### 테스트 시나리오
> 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합으로, 테스트 케이스들을 적용하는 구체적인 절차를 명세한 문서이다.

- 테스트 시나리오에는 테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정되어 있다.
- 테스트 시나리오는 시스템별, 모듈별, 항목별 등과 같이 여러 개의 시나리오로 분리하여 작성해야 한다.
- 각각의 테스트 항목은 식별자 번호, 순서 번호, 테스트 데이터, 테스트 케이스, 예상 결과, 확인 등을 포함해서 작성해야 한다.
- 테스트 시나리오는 유스케이스(Use Case) 간 업무 흐름이 정상적인지를 테스트할 수 있도록 작성해야 한다.

### 테스트 오라클
> 테스트 결과가 올바른지 판단하기 위해 사전에 정의된참 값을 대입하여 비교하는 기법 및 활동이다.

- 참(True) 오라클 : 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클로, 발생된 모든 오류를 검출할 수 있음
- 샘플링(Sampling) 오라클 : 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클
- 추정(Heuristic) 오라클 : 샘플링 오라클을 개선한 오라클 로, 특정 테스트 케이스의 입력값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클
- 일관성 검사(Consistent) 오라클 : 애플리케이션의 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클

### 테스트 자동화 도구 유형
> 사람이 반복적으로 수행하던 테스트 절차를 테스트 자동화 도구를 사용함으로써 휴먼 에러(Human Error) 를 줄이고 테스트의 정확성을 유지하면서 테스트의 품질을 향상시킬 수 있다.

- 정적 분석 도구(Static Analysis Tools) : 프로그램을 실행 하지 않고 분석하는 도구로, 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함 등을 발견 하기 위해 사용됨
- 테스트 실행 도구(Test Execution Tools) : 스크립트 언어를 사용하여 테스트를 실행하는 방법으로, 테스트 데이터와 테스트 수행 방법 등이 포함된 스크립트를 작성한 후 실행함
- 성능 테스트 도구(Performance Test Tools) : 애플리케이 션의 처리량, 응답 시간, 경과 시간, 자원 사용률 등을 인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부를 확인함
- 테스트 통제 도구(Test Control Tools) : 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구로, 종류에는 형상 관리 도구, 결함 추적/관리 도구 등이 있음
- 테스트 하네스 도구(Test Harness Tools) : 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상 적으로 테스트 되도록 하는 도구

### 결함 관리
> 결함은 오류 발생, 작동 실패 등과 같이 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것을 의미

- 결함 관리 프로세스 처리 순서 : 결함 관리 계획 → 결함 기록 → 결함 검토 → 결함 수정 → 결함 재확인 → 결함 상태 추적 및 모니터링 활동 → 최종 결함 분석 및보고서 작성

![image](https://user-images.githubusercontent.com/81230679/136407618-48263cd3-2c52-4ccd-9eb0-0d04022c5dd4.png)

- 결함 추적 순서 : 결함 등록(Open) → 결함 검토 (Reviewed) → 결함 할당(Assigned) → 결함 수정(Resolved) → 결함 종료(Closed) → 결함 해제 (Clarified)
※ Fixed(고정) : 개발자가 필요한 변경 작업을 수행하여 결함 수정 작업을 완료한 상태

![image](https://user-images.githubusercontent.com/81230679/136407964-88fe9c48-670d-4859-b19f-1b6193fde2a9.png)

- 결함 우선순위 : 결정적(Critical), 높음(High), 보통 (Medium), 낮음(Low) 또는 즉시 해결, 주의 요망, 대기, 개선 권고 등

### 애플리케이션 성능
> 사용자가 요구한 기능을 최소한의 자원을 사용해 최대한 많은 기능을 신속하게 처리하는 정도를 나타냄

![image](https://user-images.githubusercontent.com/81230679/136410626-15b608f4-5a6f-42c0-bacf-d3d1def68f6f.png)

### 소스 코드 최적화
> 나쁜 코드를 배제하고, 클린 코드로  작성하는 것

- 클린 코드 : 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순, 명료한 코드
  - 클린코드 작성 원칙 : 가독성, 단순성, 의존성, 배제, 중복성 최소화, 추상화
- 나쁜 코드 : 코드의 로직이 서로 얽혀있는 스파게티 코드 등 프로그램의 로직이 복잡하고 이해하기 어려운 코드
#### 소스코드 최적화 유형
- 클래스 분할 배치 : 하나의 클래스는 하나의 역할만 수행하도록 응집도를 높이고, 크기를 작게 작성
- 느슨한 결합 : 인터페이스 클래스를 이용해 추상화된 자료 구조와 메소드를 구현함으로써 클래스 간 의존성 최소화
- 코딩 형식 준수, 좋은 이름사용, 적절한 주석

# SQL 응용
## DDL 
> Data Define Language, 데이터 정의어. DB구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어

- 번역한 결과가 데이터 사전이라는 특별한 파일에 여러 개의 테이블로서 저장됨.
- CREATE  SCHEMA,  CREATE  DOMAIN,  CREATE  TABLE,  CREATE  VIEW,  CREATE  INDEX, ALTER TABLE, DROP 등이 있음

###  DDL - CREATE TABLE
> 테이블을 정의하는 명령문

```ddl
 CREATE TABLE 테이블명
  (속성명 데이터_타입 [DEFAULT 기본값] [NOT NULL], ... 
  [, PRIMARY KEY(기본키_속성명, ...)]
  [, UNIQUE(대체키_속성명, ...)]
    [, FOREIGN KEY(외래키_속성명, ...)]
    [REFERENCES 참조테이블(기본키_속성명, ...)] [ON DELETE 옵션]
    [ON UPDATE 옵션]
  [, CONSTRAINT 제약조건명] [CHECK (조건식)]);
```

- PRIMARY KEY : 기본키로 사용할 속성 또는 속성의 집 합을 지정함
- UNIQUE : 대체키로 사용할 속성 또는 속성의 집합을 지 정하는 것으로 UNIQUE로 지정한 속성은 중복된 값을  가질 수 없음
- FOREIGN KEY ~ REFERENCES ~
  - ON DELETE 옵션 : 참조 테이블의 튜플이 삭제되었 을 때 기본 테이블에 취해야 할 사항을 지정함. 옵션 에는 NO ACTION, CASCADE, SET NULL, SET DEFAULT가 있음
  - ON UPDATE 옵션 : 참조 테이블의 참조 속성 값이 변경되었을 때 기본 테이블에 취해야 할 사항을 지정함. 옵션에는 NO ACTION, CASCADE, SET NULL, SET DEFAULT가 있음
-  CONSTRAINT : 제약 조건의 이름을 지정함. 이름을 지 정할 필요가 없으면 CHECK절만 사용하여 속성 값에  대한 제약 조건을 명시함
- CHECK : 속성 값에 대한 제약 조건을 정의함

### 다른 테이블을 이용한 테이블 정의
> 기존 테이블의 정보를 이용해 새로운 테이블을 정의할 수 있음

```ddl
 CREATE TABLE 신규테이블명 AS SELECT 속성명[, 속성명, ...] FROM 기존테이블명;
 ```

 <img width="373" alt="image" src="https://user-images.githubusercontent.com/81230679/136491511-5d652bcd-9122-4529-81b7-cbb54acd18ae.png">

<img width="378" alt="image" src="https://user-images.githubusercontent.com/81230679/136491562-78f595a4-4e28-4caa-85a4-4e3a1f24eed3.png">

## DDL - CREATE VIEW
> 뷰(View)를 정의하는 명령문

```ddl
 CREATE VIEW 뷰명[(속성명[, 속성명, ...])]
 AS SELECT문;
 ```

- SELECT문을  서브  쿼리로  사용하여  SELECT문의  결 과로서 뷰를 생성한다.
- 서브 쿼리인 SELECT문에는 UNION이나 ORDER BY 절을 사용할 수 없다.
- 속성명을  기술하지  않으면  SELECT문의  속성명이  자 동으로 사용된다.

<img width="391" alt="image" src="https://user-images.githubusercontent.com/81230679/136491803-6f78b520-c9b1-499d-88ac-bc962634cd0e.png">

## DDL - ALTER TABLE
> 테이블에 대한 정의를 변경하는 명령문

```ddl
ALTER TABLE 테이블명 ADD 속성명 데이터_타입 [DEFAULT ‘기본값’];
ALTER TABLE 테이블명 ALTER | MODIFY 속성명 [SET DEFAULT ‘기본값’];
ALTER TABLE 테이블명 DROP COLUMN 속성명 [CASCADE];
```

- ADD : 새로운 속성(열)을 추가할ㄷ 때 사용
- ALTER | MODIFY : 특정 속성의 정의를 변경할 떄 사용
- DROP COLUMN : 특정 속성의 삭제할 때 사용

<img width="395" alt="image" src="https://user-images.githubusercontent.com/81230679/136492060-3598cb70-16d3-49b7-a186-80bb62d7bc28.png">

## DDL - DROP TABLE
> 기본 테이블을 제거하는 명령문

```ddl
DROP TABLE 테이블명 [CASCADE | RESTRICTED];
```

- CASCADE : 제거할 요소를 참조하는 다른 모든 개체를 함께 제거. 주 테이블의 데이터 제거 시 각 외래키와 관계를 맺고 있는 모든 데이터를 제거하는 참조 무결성 제약 조건을 설정하기 위해 사용됨
- RESTICTED : 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소함

## DCL
> Data Control Language, 데이터 제어어. 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는데 사용하는 언어

- DCL은 DB 관리자(DBA)가 데이터 관리르 목적으로 사용
-  DCL에는  GRANT,  REVOKE,  COMMIT,  ROLLBACK, SAVEPOINT 등이 있음
### DCL - GRANT / REVOKE
> DBA가 DB사용자에게 권한을 부여하거나 취소하기 위한 명렁어

- GRANT : 권한 부여를 위한 명렁어
- REVOKE : 권한 취소를 위한 명령어

- 사용자등급 지정 및 해제

```ddl
GRANT 사용자등급 TO 사용자_ID_리스트 [IDENTIFIED BY 암호];
REVOKE 사용자등급 FROM 사용자_ID_리스트;
```

- 테이블 및 속성에 대한 권한 부여 취소

```ddl
GRANT 권한_리스트 ON 개체 TO 사용자 [WITH GRANT OPTION];
REVOKE [GRANT OPTION FOR] 권한_리스트 ON 개체 FROM 사용자 [CASCADE];
```

- 권한 종류 : ALL, SELECT, INSERT, DELETE, UPDATE, ALTER 등
- WITH GRANT OPTION : 부여받은 권한을 다른 사용자 에게 다시 부여할 수 있는 권한을 부여함
- GRANT OPTION FOR : 다른 사용자에게 권한을 부여 할 수 있는 권한을 취소함
- CASCADE : 권한 취소 시 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 연쇄적으로 취소함

<img width="398" alt="스크린샷 2021-10-08 오후 12 15 49" src="https://user-images.githubusercontent.com/81230679/136492788-4d0b7d7d-47c7-4127-99c9-86e8bbb4c59d.png">

### COMMIT / ROLLBACK / SAVEPOINT

- COMMIT : 트랜잭션이 성공적으로 끝나면 DB가 새로운 일관성 상태를 가지기 위해 변경되 모든 내용을 DB에 반영할 때 사용하는 명령어
- ROLLBACK : 아직 COMMIT되지 않은 변경된 모든 내용들을 취소하고 DB를 이전 상태롤 되돌리는 명렁어
- SAVEPOINT : 트랜잭션 내 ROLLBACK할 위치인 저장점을 지정하는 명령어. 저장점 지정 시 이름을 부여, ROLLBACK시 지정된 저장점까지의 트랜잭션 처리 내용이 취소됨

## DML - 삽입, 삭제, 갱신문
> Data Manipulation Language, 데이터 조작어. DB사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 관리하는데 사용되는 언어

- DML에는 SELECT, INSERT, DELETE, UPDATE 등 이 있음

### 삽입문(INSERT INTO ~ )
- 기존 테이블에 새로운 튜플 삽입 시 사용

```dml
INSERT INTO 테이블명(속성명1, 속성명2,... )
VALUES (데이터1, 데이터2,... );
```

### 삭제문(DELETE INTO ~ )
- 기존  테이블에 있는 튜플 중에서 특정 튜플을 삭제할 때 사용

```dml
DELETE
FROM 테이블명
[WHERE 조건];
```

### 갱신문 (UPDATE ~ SET ~ )
- 기본 테이블에 있는 튜플 중에서 특정 튜플의 내용을 변경할 때 사용

```dml
UPDATE 테이블명
SET 속성명 = 데이터[, 속성명=데이터]
[WHERE 조건];
```

### DML -  SELECT

```dml
SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블 명.]속성명, ...] [, 그룹함수(속성명) [AS 별칭]]
FROM 테이블명[, 테이블명, ...]
[WHERE 조건]
[GROUP BY 속성명, 속성명, ...] [HAVING 조건]
[ORDER BY 속성명 [ASC | DESC]];
```

- SELECT절
  -  PREDICATE : 불러올 튜플 수를 제한할 명령어 기술
    -  ALL : 모든 튜플을 검색할 때 지정하는 것으로,  주로 생략함
    -  DISTINCT : 중복된 튜플이 있으면 그 중 첫 번째  한 개만 검색함
    - DISTINCTROW : 중복된 튜플을 검색하지만 선택 된 속성의 값이 아닌, 튜플 전체를 대상으로 함
  - 속성명 : 검색해 불러올 속성(열) 및 수식들을 지정
    - 기본 테이블을 구성하는 모든 속성을 지정할 때 는 ‘*’ 를 기술함
    - 두 개 이상의 테이블을 대상으로 검색할 때는 ‘테 이블명.속성명’으로 표현함
  - AS : 속성 및 연산의 일므을 다른 제목으로 표시하기 위해 사용
- FROM 절 : 질의에 의해 검색될 데이터들을 포함하는 테이블명 기술
- WHERE 절 : 검색할 조건 기술
- GROUP BY 절 : 특정 속성을 기준으로 그롭화해 검색할 때 그룹화 할 속성을 지정
  - 일반적으로 GROUP BY 절은 그룹 함수와 함께 사용

<img width="402" alt="image" src="https://user-images.githubusercontent.com/81230679/136493856-7f02394a-d1c3-41a0-8f10-a381d6aec4ba.png">

- HAVING절 : GROUP BY와 함께 사용되며, 그룹에 대 한 조건을 지정함
- ORDER BY절 : 특정 속성을 기준으로 정렬하여 검색할  때 사용함
  - 속성명 : 정렬의 기준이 되는 속성명을 기술함
  - [ASC | DESC] : 정렬 방식으로서 ‘ASC’는 오름차 순,  ‘`DESC`’는  내림차순임.  생략하면  오름차순으로  지정됨

#### SELEC문의 실행 작동 순서
FROM → WHERE → GROUP BY → HAVING → SELECT → DISTINCT → ORDER BY

### 하위 질의
- 조건절에 주어진 질의를 먼저 수행하여 그 검색 결과를 조건절의 피연산자로 사용

<img width="402" alt="image" src="https://user-images.githubusercontent.com/81230679/136494071-4c9892f8-37dd-4593-8956-9c898e8c18f4.png">

<img width="395" alt="image" src="https://user-images.githubusercontent.com/81230679/136494109-f90c061c-a1e1-4be2-89e4-4c5ccfae2e3a.png">

### DML - JOIN
> 2개의 테이블에 대해 연관된 튜플들을 결합해 하나의 새로운 릴레이션을 반환

- 크개 INNER JOIN, OUTER JOIN으로 구분
- 일반적으로 FROM절에 기술하지만, 릴레이션이 사용되는 어느 곳에서나 사용할 수 있음

#### INNER JOIN
> 가장 일반적인 형태로 관계가 설정된 두 테이블에서 조인된 필드가 일치하는 행만을 표시

- WHERE 절을 이용한 표기 형식

```dml
SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1, 테이블명2, ...
WHERE 테이블명1.속성명 = 테이블명2.속성명;
```

- NATURAL JOIN을 이용한 표기 형식

```dml
SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... 
FROM 테이블명1 NATURAL JOIN 테이블명2;
```

- JOIN ~ USING절을 이용한 표기 형식

```dml
SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... 
FROM 테이블명1 JOIN 테이블명2 USING(속성명);
```

#### OUTER JOIN
> 릴레이션에서 JOIN 조건에 만족하지 않는 튜플도 결과로 출력하기 위한 JOIN 방법으로, LEFT OUTER JOIN, RIGHT OUTER JOIN등이 있음

- LEFT OUTER JOIN : INNER JOIN의 결과를 구한 후,  우측  항  릴레이션의  어떤  튜플과도  맞지  않는  좌측  항의  릴레이션에  있는 튜플들에  NULL  값을  붙여서  INNER JOIN의 결과에 추가함

```dml
 SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1
 LEFT OUTER JOIN 테이블명2
 ON 테이블명1.속성명 = 테이블명2.속성명;
 ```

- RIGHT OUTER JOIN : INNER JOIN의 결과를 구한 후,  좌측  항  릴레이션의  어떤  튜플과도  맞지  않는  우측  항의  릴레이션에  있는  튜플들에  NULL  값을  붙여서  INNER JOIN의 결과에 추가함

```dml
SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1
RIGHT OUTER JOIN 테이블명2
ON 테이블명1.속성명 = 테이블명2.속성명;
```

### 프로시저
- 절차형 SQL을 활용해 특정 기능을 수행하는 일종의 트랜잭션 언어로, 호출을 통해 실행되어 미리 저장해 놓은 SQL작업을 수행
- 프로시저는 DB에 저장되어 수행되기 때문에 스토어드 프로시저 라고도 불림
- 시스템의 일일 마감 작업, 일괄 작업 등에 주로 사용

<img width="404" alt="image" src="https://user-images.githubusercontent.com/81230679/136501236-918f0c9e-4c3a-483b-92ed-3cbcd146c09f.png">

### SQL - 트리거
> DB 시스템에서 테이터 삽입, 갱신, 삭제 등의 이벤트가 발생할 때 마다 관련 작업이 자동으로 수행되는 절차형 SQL

- 트리거는 DB에 저장되며 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 사용됨

<img width="394" alt="image" src="https://user-images.githubusercontent.com/81230679/136501530-b837e40f-0f18-4121-a6bb-4bfb0e4d07bd.png">

- 트리거의 제거

```sql
DROP TRIGGER 트리거명;
```

### SQL - 사용자 정의 함수
> 프로시저와 유사하게 SQL을 사용해 일련의 작업을 연속적으로 처리하며, 종료 시 처리 결과를 단일 값으로 반환하는 절차형 SQL

- 사용자 정의 함수는 DB에 저장되어 SELECT, INSERT, DELETE, UPDATE등 DML문의 호출에 의해 실행됨
- 사용자 정의 함수는 예약어 RETURN을 통해 값을 반환하기에 출력 파라미터가 없음

<img width="366" alt="image" src="https://user-images.githubusercontent.com/81230679/136501683-8280cada-f88e-4120-8b8d-4504dc6f74d4.png">

<img width="387" alt="image" src="https://user-images.githubusercontent.com/81230679/136501710-d0045cb2-0174-425e-863f-8f0a481d0874.png">

<img width="385" alt="image" src="https://user-images.githubusercontent.com/81230679/136501753-a9f33c96-ffaf-400c-b6f7-f7128d916aea.png">

### SQL - 커서
> 쿼리문의 처리 결과가 저장되어 있는 메모리 공간을 가리키는 포인터

- 내부에서 자동으로 생성되어 사용되는 묵시적 커서, 사용자가 직접 정의해 사용하는 명시적 커서
- 커서의 수행은 open, fetch, close의 세 단계로 구성

#### 묵시적 커서
> DBMS  자체적으로  열리고(Open)  패치(Fetch)되어  사 용이 끝나면 닫히지만(Close) 커서의 속성을 조회하여  사용된 쿼리 정보를 열람하는 것이 가능하다.

<img width="391" alt="image" src="https://user-images.githubusercontent.com/81230679/136501882-68349081-15e3-4115-ba98-77984439499a.png">

#### 명시적 커서
>   사용자가 직접 정의해서 사용하는 커서로, 주로 절차형  SQL에서  SELECT문의  결과로  반환되는  여러  튜플들 을 제어하기 위해 사용

- 기본적으로 열기(Open)-패치(Fetch)-닫기(Close) 순으로 이루어지며, 명시적 커서로 사용하기 위해서는 열기 전에 선언을 해야함

# 소프트웨어 개발 보안 구축
## 소프트웨어 개발의 비용 산정 기법
> 소프트웨어의 개발 규모를 소요되는 인원, 자원, 기간 등으로 확인해 실행 가능한 계획을 수립하기 위해 필요한 비용을 산정하는 것

### 하향식 산정 기법
> 과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 비과학적 방법

- 종류
  - 전문가 감정 기법 : 조직 내 경험이 많은 두 명이상의 전문가에게 비용 산정을 의뢰
  - 델파이 기법 : 전만가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가의 읜겨을 종합해 산정

### 상향식 비용 산정 기법
> 프로젝트의 세부적인 작업 단위별로 비용을 산정한 후 집계해 전체 비용을 산정하는 방법

- 종류
  - LOC기법 : 소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정해 예측치를 구하고 이를 이용해 비용을 산정
    - 노력(인월) = 개발 기간 × 투입 인원 = LOC / 1인당 월평균 생산 코드라인수
    - 개발비용=노력(인월) × 단위 비용 (1인당 월평균 인건비)
    - 개발 기간 = 노력(인월) / 투입 인원
    - 생산성 = LOC / 노력(인월)
    - ex) LOC기법에의하여예측된총라인수가 40,000라인, 개발에 참여할 프로그래머가 10명, 프로그래머들의 평균 생산성이 월간 400라인일 때 개발에 소요되는 기간은?
    •노력(인월) = LOC/1인당 월평균 생산 코 드 라인 수 = 40000/400 = 100명
    •개발 기간 = 노력(인월)/투입 인원 = 100/10 = 10개월
  - 개발 단계별 인월수 기법 : LOC기법을 보완하기 위해 만든 기법, 각 기능을 구현시키는데 필요한 노력을 생명 주기의 각 단계별로 산정

## 서비스 거부 공격
> 표적이 되는 서버의 자원을 고갈시킬 목적으로 다수의 공격자 또는 시스템에서 대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써 표적이 되는 서버의 정상적인 기능을 방해

![image](https://user-images.githubusercontent.com/81230679/136505092-028140ef-1109-4bdb-8312-b6d03f2791d9.png)

![image](https://user-images.githubusercontent.com/81230679/136505121-48fc577e-ecf3-4a82-98c4-12340da10551.png)

### 네트워크 침해 공격 관련 용어

![image](https://user-images.githubusercontent.com/81230679/136505339-56b28cbb-7bd8-4371-ab39-402d04f8a705.png)

![image](https://user-images.githubusercontent.com/81230679/136505387-2449a0f7-49bf-48eb-860a-a370a04e6c16.png)

### 정보 보안 침해 공격 관련 용어

![image](https://user-images.githubusercontent.com/81230679/136505636-734f7d8c-8f35-46eb-9dd9-46beadce9352.png)

![image](https://user-images.githubusercontent.com/81230679/136505667-04fafbd6-8eac-4b3e-8d7d-1d379f933964.png)

### 소프트웨어 개발 보안
> 소프트웨어 개발 과정에서 발생할 수 있는 보안 취약점을 최소화해 보안 위협으로부터 소프트웨어를 개발하기 위한 일련의 보안 활동을 의미

- 기밀성, 무결성, 가용성을 유지하는 것을 목표로 함
- 소프트웨어 개발 보안 관련 기관
  - 행정안전부 : 소프트웨어 개발 보안 정책을 총괄
  - 한국인터넷진흥원 : 소프트웨어 개발 보안 정책 및 가이드 개발
  - 발주기관 : S/W 개발 보안의 계획 수립
  - 사업자 : S/W 개발 보안 관련 기술 수준 및 적용 계획 명시
  - 감리법인 : 감리 계획 수립, 협의

### Secure SDLC
> 보안상 안전한 S/W개발을 위해 SDLC에 보안 강화를 위한 프로세스를 포함한 것

- SDLC(소프트웨어 개발 생명주기) : S/W 개발 방법론의 바탕이 되는 것. S/W 개발을 위해 정의하고 운용, 유지보수 등의 전 과정을 각 단계별로 나눈 것

![image](https://user-images.githubusercontent.com/81230679/136507392-3289b39c-c54b-4fbf-8531-c7d3029c2efa.png)

![image](https://user-images.githubusercontent.com/81230679/136507409-cd7bff47-5dd4-4c97-b282-727aaf656a02.png)

# 소프트웨어 개발 보안 구축

## 보안요소
> 소프트웨어 개발에 있어 충족시켜야 할 요소 및 요건

- 기밀성, 무결성, 가용성이 있으며 그 외에도 인증 부인방지 등이 있음

<img width="391" alt="image" src="https://user-images.githubusercontent.com/81230679/136510059-06ab1373-b1c9-4ae9-b4aa-866e8d3080e6.png">

### 보안 점검 - 세션 통제
> 세션은 서버와 클라이언트의 연결을 의미하고 세션 통제는 세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것을 의미

- 세션 통제는 소프트웨어 개발 과정 중 요구사항 분석 및 설계 단계에서 진단해야 하는 보안 점검 내용

<img width="390" alt="image" src="https://user-images.githubusercontent.com/81230679/136510207-46162dc5-c0ea-4525-b452-5483196c18c3.png">

### 보안 점검 - 입력 데이터 검증 및 표현
> 입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목들

<img width="385" alt="스크린샷 2021-10-08 오후 3 41 55" src="https://user-images.githubusercontent.com/81230679/136510434-dbe5d338-878c-4305-94f4-f85c87153925.png">

<img width="384" alt="스크린샷 2021-10-08 오후 3 42 12" src="https://user-images.githubusercontent.com/81230679/136510504-d3572d60-51b0-49f7-aef3-ef1dd39f97c5.png">

### 보안 점검 - 보안 기능
> 스포트웨어 개발의 구현 단계에서 코딩하는 기능인 인증, 접근 제어, 기밀성, 암호화 등 올바르게 구현하기 위한 보안 점검 항목들

<img width="390" alt="image" src="https://user-images.githubusercontent.com/81230679/136510642-6a2ac5a1-f66c-4b86-93a0-7d685d235bfb.png">

<img width="384" alt="image" src="https://user-images.githubusercontent.com/81230679/136510676-46f53811-af5a-4cde-98c1-9aea708be0cb.png">

### 보안 점검 - 시간 및 상태
> 동시 수행을 지원하는 병렬 처리 시스템이나 다수의 프로세스가 동작하는 환경에서 시간과 길행 상태를 관리해 시스템이 원화랗게 동작되도록 하기 위한 보안 검증 항목들

<img width="388" alt="스크린샷 2021-10-08 오후 3 46 12" src="https://user-images.githubusercontent.com/81230679/136510814-af8ce8bb-708f-4f60-9df3-18539086e0ab.png">

### 보안 점검 - 에러 처리
> 소프트웨어 실행 중 발생할 수 있는 오류들을 사전에 정의해 오류로 인해 발생할 수있는 문제들을 예방하기 위한 보안 점검 항목들

<img width="389" alt="image" src="https://user-images.githubusercontent.com/81230679/136510984-b2b6920a-3a5d-46e4-9d9e-d743360e1bee.png">

### 보안 점검 - 코드 오류
> 소프트웨어 구현 단계에서 개발자들이 코딩 중 실수하기 쉬운 Type변환, 자원 반환 등의 오류를 예방하기 위한 보안 점검 항목들

<img width="394" alt="image" src="https://user-images.githubusercontent.com/81230679/136511016-1db10362-476f-47e0-bb8c-6390863ec801.png">


### 보안 점검 - 캡슐화
> 정보 은닉이 필요한 중요한 데이터와 기능을 불충분하게 캡슐화 하거나 잘못 사용함으로써 발생할 수 있는 문제를 예방하기 위한 보안 점검 항목

<img width="376" alt="image" src="https://user-images.githubusercontent.com/81230679/136511278-ca3d49a1-044e-4b62-926e-425ad43b01e1.png">

### 보안 점검 - API 오용
> 소프트웨어 구현 단게에서 API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 하기 위한 보안 검증 항목들

<img width="424" alt="image" src="https://user-images.githubusercontent.com/81230679/136511355-fafb13a4-1bba-408d-a651-62be4221da9e.png">

### 암호 알고리즘
> 패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법

- 암호 알고리즘은 해시를 사용하는 단방향 암호화 방식, 개인키 및 공개키로 분류되는 양방향 암호화 방식이 있음

<img width="426" alt="image" src="https://user-images.githubusercontent.com/81230679/136511555-4911c9a5-0f32-4f5a-90eb-a40d5dc96fde.png">


# 응용 SW 기초 기술 활용
## OS
> 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임

- 목적 : 처리 능력 향상, 신뢰도, 사용 가능도 향상, 반환 시간 단축
- 기능
  - 프로세서, 기억장치, 입·출력장치, 파일 및 정보 등 의 자원 관리
  - 자원의 효과적인 경영 스케줄링 기능 제공
  - 사용자와 시스템 간의 편리한 인터페이스 제공
  - 시스템의 각종 하드웨어와 네트워크 관리·제어 -시스템의 오류 검사 및 복구, 데이터 관리, 데이터 및 자원 공유

### Windows
- GUI : 키보드로 명령어를 직접 입력하지 않고 마우스로 아이콘이나 메뉴를 선택해 모든 작업 수행
- 선점형 멀티테스킹 : 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하며 OS가  각 작업의 CPU 이용시간을 제어하며 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료 시키고, 모든 시스템 자원을 반환하는 방식
- PnP(자동 감지 기능) : 컴퓨터 시스템에 하드웨어를 설치했을 때 해당 하드웨어를 사용하는데 필요한 시스템 환경을 OS가 자동적으로 구성해주는 기능
- OLE : 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체를 현재 작업 중인 문서에 자유롭게 연결하거나 삽입해 편집할 수 있게 하는 기능

<img width="410" alt="image" src="https://user-images.githubusercontent.com/81230679/136513205-d384e666-2856-4301-a520-75ccf8a03b45.png">


### UNIX
> 60년대 벨 연구소, MIT, General Electric이 공동 개발. 시분할 시스템을 위해 설계된 대화식 OS로 소스가 공개된 개방형 시스템. 대부분 C언어로 작성되어 있어 이식성이 높으며 장치, 프로세스간 호환성이 높음

- 다중 사용자, 다중 작업 지원
- 트리 구조의 파일 시스템

### LINUX
> 91년 리누스 토발즈가 UNIX기반으로 개발. UNIX와 완벽한 호환, 대부분의 특징이 비슷

- 프로그램 소스 코드가 무료 공개

#### UNIX 시스템의 구성
- 커널
> 가장 핵심적인 부분. 하드웨어를 보호(캡슐화)하고 프로그램들과 하드웨어간 인터페이스 역할

  - 프로세스, 기억장치, 파일, 입.출력 관리, 프로세스 간 통신, 데이터 전송 및 변환 등 여러 가지 기능을 수행
  - 컴퓨터 부팅 시 주기억장치에 적재되어 상주하면서 실행됨

- 쉘
> 사용자의 명령어를 인식해 프로그램을 호출, 명령을 수행하는 명령어 해석기

  - 시스템과 사용자 간 인터페이스 담당
  - DOS의 COMMAND.COM과 같은 기능 수행
  - 주기억장치에 상주하지 않고 명령어가 포함된 파일 형태로 존재하며 보조기억장치에서 교체처리가 가능
  - Bournce Shell, C Shell, Korn Shell 등

<img width="428" alt="image" src="https://user-images.githubusercontent.com/81230679/136513304-bdb10c65-f6c0-46f4-8cba-00f337c23668.png">

<img width="415" alt="image" src="https://user-images.githubusercontent.com/81230679/136513320-3194d43b-84d5-4bfa-b07b-08ff733e94ac.png">

### 기억장치 관리 전략
> 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정해 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것

- Fetch(반입) 전략 : 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략으로 요구반입, 예상반입이 있음
- 배치 전략 : 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략
  - 최초 적합 : 프로그램이나 데이터가 들어갈 수  있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치 시키는 방법
  - 최적 적합 : 프로그램이나 데이터가 들어갈 수  있는 크기의 빈 영역 중에서 단편화를 가장 **작게** 남기 는 분할 영역에 배치시키는 방법
  - 최악 적합 : 프로그램이나 데이터가 들어갈 수  있는 크기의 빈 영역 중에서 단편화를 가장 **많이** 남기 는 분할 영역에 배치시키는 방법
- 교체 전략 : 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로 운  프로그램이나  데이터를  주기억장치에  배치하려고  할  때,  이미  사용되고  있는  영역  중에서  어느  영역을  교체 하여  사용할  것인지를  결정하는  전략으로,  FIFO,  OPT,  LRU, LFU, NUR, SCR 등이 있음

### 가상 기억장치
> 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로,용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 것. 현재 사용되는 운영체제에서 흔히 사용되는 기법

- 가상 기억장치 구현 기법
  - 페이징 기법 : 가상 기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나 눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법으로, 외부 단편화는 발생하지 않으나 내부 단편화는 발생 할 수 있음
  -  세그먼테이션(Segmentation) 기법 : 가상 기억장치에 보 관되어 있는 프로그램을 다양한 크기의 논리적인 단 위로 나눈 후 주기억장치에 적재시켜 실행시키는 기 법으로, 내부 단편화는 발생하지 않으나 외부 단편화 는 발생할 수 있음

### 기억장치 기타 관리 사항
- Locality(국부성)
  - 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론
  - 시간 구역성(Temporal Locality) : 프로세스가 실행되면 서하나의페이지를일정시간동안집중적으로액세 스하는 현상
  - 공간 구역성(Spatial Locality) : 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상
- 워킹 셋(Working Set) : 프로세스가 일정 시간 동안 자주  참조하는 페이지들의 집합
- 페이지 부재(Page Fault) : 프로세스 실행 시 참조할 페 이지가  주기억장치에  없는  현상으로,  페이지  부재 가  일어나는  횟수를  페이지  부재  빈도(Page  Fault  Frequency)라고 함
- 스래싱(Thrashing) : 프로세스의 처리 시간보다 페이지  교체에 소요되는 시간이 더 많아지는 현상

### 페이지 교체 알고리즘
- OPT(OPTimal replacement, 최적 교체) : 앞으로 가장 오랫
동안 사용하지 않을 페이지를 교체하는 기법
- FIFO(First In First Out) : 각 페이지가 주기억장치에 적재 될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서  가장 오래 있었던 페이지를 교체하는 기법
- LRU(Least Recently Used) : 최근에 가장 오랫동안 사용 하지 않은 페이지를 교체하는 기법
- LFU(Least Frequently Used) : 사용 빈도가 가장 적은 페 이지를 교체하는 기법
- NUR(Not Used Recently) : 최근에 사용하지 않은 페이지 를 교체하는 기법으로, 참조 비트(Reference Bit)와 변 형 비트(Modified Bit)가 사용됨
- SCR(Second Chance Replacement, 2차 기회 교체) : 가장  오랫동안 주기억장치에 있던 페이지 중 자주 사용되는  페이지의 교체를 방지하기 위한 것으로, FIFO 기법의  단점을 보완하는 기법

### 프로세스 관리
> 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미하며 작업, 태스크 라고도 함

<img width="430" alt="image" src="https://user-images.githubusercontent.com/81230679/136515156-bdb628a6-8adc-41ca-be46-80e48b4d43e6.png">
<img width="425" alt="image" src="https://user-images.githubusercontent.com/81230679/136515192-aab4aebb-eca9-43d4-a348-4dfa8d745a86.png">

### 비선점 스케줄링
> 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 이미 사용할 수 없는 스케줄링 기법

- FCFS(First Come First Service, 선입 선출) = FIFO(First In First Out) :  준비상태  큐에  도착한  순서에  따라  차례로  CPU를 할당하는 기법으로, 가장 간단한 알고리즘임
- SJF(Shortest Job First, 단기 작업 우선) : 준비상태 큐에서  기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧 은 프로세스에게 먼저 CPU를 할당하는 기법
- HRN(Hightest Response-ratio Next)
  - 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완 하기 위한 것으로, 대기 시간과 서비스(실행) 시간을 이용하는 기법
  - 우선순위 계산식 : (대기 시간+서비스 시간) / 서비스 시간
- 기한부(Deadline) : 프로세스에게 일정한 시간을 주어 그  시간 안에 프로세스를 완료하도록 하는 기법
- 우선순위(Priority) : 준비상태 큐에서 기다리는 각 프로세 스마다 우선순위를 부여하여 그 중 가장 높은 프로세스 에게 먼저 CPU를 할당하는 기법

!! 에이징 기법 : 시스템에서 특정 프로세스의 우선순위가 낮아 무한정 기다리게 되는 경우, 한 번 양보하거나 기다린 시간에 비례해 일정 시간이 지나면 우선순위를 한 단계씩 높여 가까운 시간 안에 자원을 할당 받도록 하는 기법

### 선점 스케줄링
> 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법

- 선점 우선순위 : 준비상태 큐의 프로세스들 중에서 우선 순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는  기법
- SRT(Shortest Remaining Time) : 비선점 스케줄링인 SJF  기법을  선점  형태로  변경한  기법으로,  선점  SJF  기법 이라고도 함
- 라운드 로빈(RR; Round Robin) : 시분할 시스템(Time  Sharing  System)을  위해  고안된  방식으로,  FCFS  기 법과 같이 준비상태 큐에 먼저 들어온 프로세스가 먼저  CPU를  할당받지만  각  프로세스는  시간  할당량(Time  Slice,  Quantum)  동안만  실행한  후  실행이  완료되지  않으면 다음 프로세스에게 CPU를 넘겨주고 준비상태  큐의 가장 뒤로 배치됨
- 다단계 큐(MQ; Multi-level Queue) : 프로세스를 특정 그 룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준 비상태 큐를 사용하는 기법
- 다단계 피드백 큐(MFQ; Multi-level Feedback Queue) : 특 정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비 상태 큐로 이동할 수 없는 다단계 큐 기법을 준비상태  큐 사이를 이동할 수 있도록 개선한 기법

### 교착상태(Dead Lock)
> 상호 배제에 의해 나타나는 문제점으로 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상

#### 교착상태 발생의 필요 충분 조건
- 상호 배제(Mutual Exclusion) : 한 번에 한 개의 프로세
스만이 공유 자원을 사용할 수 있어야 함
- 점유와 대기(Hold and Wait) : 최소한 하나의 자원을 점 유하고 있으면서 다른 프로세스에 할당되어 사용되 고 있는 자원을 추가로 점유하기위해 대기하는 프로 세스가 있어야 함
- 비선점(Non-preemption) : 다른 프로세스에 할당된 자원 은사용이끝날때까지강제로빼앗을수없어야함
- 환형 대기(Circular Wait) : 공유 자원과 공유 자원을 사 용하기 위해 대기하는 프로세스들이 원형으로 구성 되어 있어 자신에게 할당된 자원을 점유하면서 앞이 나 뒤에 있는 프로세스의 자원을 요구해야 함 

#### 교착상태 해결 방법
- 예방 기법
  - 교착상태가  발생하지  않도록  사전에  시스템을  제어하 는 방법으로, 교착상태 발생의 네 가지 조건 중에서 어 느 하나를 제거(부정)함으로써 수행된다.
  -  상호 배제(Mutual Exclusion) 부정 : 한 번에 여러 개의 프 로세스가 공유 자원을 사용할 수 있도록 함
  - 점유 및 대기(Hold and Wait) 부정 : 프로세스가 실행되기  전  필요한  모든  자원을  할당하여  프로세스  대기를  없 애거나 자원이 점유되지 않은 상태에서만 자원을 요구 하도록 함
  - 비선점(Non-preemption) 부정 : 자원을 점유하고 있는 프 로세스가 다른 자원을 요구할 때 점유하고 있는 자원을  반납하고,  요구한  자원을  사용하기  위해  기다리게  함
  - 환형 대기(Circular Wait) 부정 : 자원을 선형 순서로 분류 하여 고유 번호를 할당하고, 각 프로세스는 현재 점유 한 자원의 고유 번호보다 앞이나 뒤 어느 한쪽 방향으 로만 자원을 요구하도록 하는 것
- 회피 기법(Avoidance)
교착상태가  발생할  가능성을  배제하지  않고  교착상태가  발생하면 적절히 피해나가는 방법으로, 주로 은행원 알고 리즘(Banker’s Algorithm)이 사용된다.
- 발견(Detection) 기법
시스템에 교착 상태가 발생했는지 점검하여 교착 상태에  있는 프로세스와 자원을 발견하는 것으로, 자원 할당 그 래프 등을 사용한다.
- 회복(Recovery) 기법
교착 상태를 일으킨 프로세스를 종료하거나 교착 상태의  프로세스에  할당된  자원을  선점하여  프로세스나  자원을  회복하는 것이다.

### 데이터베이스
> 특정 조직의 업무를 수행하는데 필요한 상호 관련된 데이터들의 모음

- 통합된 데이터 : 검색의 효울성을 위해 중복이 최소화된 데이터의 모임
- 저장된 데이터 : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 데이터
- 운영 데이터 : 조직의 고유한 업무를 수행하는데 존재 가치가 확실하고 없어서는 안 될 반드시 필요한 데이터
- 공용 데이터 : 여러 응용 시스템들이 공동으로 소유하고 유지하는 데이터

#### DBMS
> 사용자와 DB사이에서 사용자의 요구에 따라 정보 생성, DB를 관리해주는 소프트웨어

- 필수 기능
  - 정의 기능 : 모든 응용 프로그램들이 요구하는  데이터  구조를  지원하기  위해  데이터베이스에  저장될  데이터의 형(Type)과 구조에 대한정의, 이용방식, 제 약 조건 등을 명시하는 기능
  - 조작 기능 : 데이터 검색, 갱신, 삽입, 삭제  등을  체계적으로  처리하기  위해  사용자와  데이터베이 스 사이의 인터페이스 수단을 제공하는 기능
- 제어 기능 : 데이터베이스를 접근하는 갱신, 삽 입,  삭제  작업이  정확하게  수행되어  데이터의  무결성 이 유지되도록 제어하는 기능

- 종류
  -  층형 DBMS : 트리(Tree) 구조를 이용해서 데이터의  상호관계를 계층적으로 정의한 DBMS로, 개체 타입 간 에는 상위(Owner)와 하위(Member) 관계가 존재하며,  일 대 다(1:N) 대응 관계만 존재함
  - 망  형 DBMS : 그래프를 이용해서 데이터 논리 구조를  표현한 DBMS로, 상위(Owner)와 하위(Member) 레코 드 사이에서 1 : 1, 1 : N, N : (다 대 다) 대응 관계를 모 두 지원함
  - 관계형 DBMS : 계층형과 망형 DBMS의 복잡한 구조를  단순화시킨 가장 널리 사용되는 DBMS로, 파일 구조처 럼 구성한 2차원적인 표(Table)를 하나의 DB로 묶어서  테이블  내에  있는  속성들  간의  관계(Relationship)를  설정하거나 테이블 간의 관계를 설정하여 이용함

#### 분산 데이터베이스
> 논리적으로 같은 시스템에 속하지만 물리적으로는 컴퓨터 네트워크를 통해 분산되어 있는 DB로 아래 목표를 가짐

- 위치 투명성 : 접근하려는 데이터 베이스의 실제 위치를 알 필요 없이 단지 데이터베이스 의 논리적인 명칭만으로 접근할 수 있음
- 중복 투명성 : 동일한 데이터가  여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데 이터만 존재하는 것처럼 사용할 수 있고, 시스템은 자 동으로 여러 데이터에 대한 작업을 수행함
- 병행 투명성 : 분산 데이터베 이스와  관련된  다수의  트랜잭션들이  동시에  실행되더 라도  그  트랜잭션들의  수행  결과는  서로  영
- 장애 투명성  :트랜잭션, DBMS,  네트워크, 컴퓨터 장애에도 불구하고 트랜잭션은 정확 하게 수행됨

#### 고급 데이터베이스
- 데이터 웨어하우스(Data Warehouse) : 급증하는 다량의  데이터를  효과적으로  분석하여  정보화하고  이를  여러  계층의 사용자들이 효율적으로 사용할 수 있도록 한 데 이터베이스
- 데이터 마트(Data Mart) : 전사적으로 구축된 데이터 웨 어하우스로부터 특정 주제나 부서 중심으로 구축된 소 규모 단일 주제의 데이터 웨어하우스를 말함
- 데이터 마이닝(Data Mining) : 데이터 웨어하우스에 저장 된 데이터 집합에서 사용자의 요구에 따라 유용하고 가 능성 있는 정보를 발견하기 위한 기법
- OLAP(Online Analytical Processing) : 다차원으로 이루어 진 데이터로부터 통계적인 요약 정보를 분석하여 의사 결정에 활용하는 방식
- OLTP(Online Transaction Processing) : 온라인 업무 처리  형태의  하나로  네트워크상의  여러  이용자가  실시간으 로  데이터베이스의  데이터를  갱신하거나  검색하는  등 의 단위 작업을 처리하는 방식

### ER모델 - ER 도형
> 개념적 데이터 모델의 가장 대표. 76년 피터 첸에 의해 제안됨

<img width="432" alt="image" src="https://user-images.githubusercontent.com/81230679/136558780-b2618ad3-9cb8-4023-bf8f-67671a1fc294.png">

### ER 모델 - 관계 및 관계 타입
> 관계는 2개 이상의 개체 사이에 존재하는 연관성을 뜻하며, 관계 타입은 같은 관계들의 집합 또는 틀을 뜻함

- 관계는 관계에 참여하는 개체 타입의 개수에 대한 차수와 관계에 참여하는 개체 어커런스의 갯수에 대한 대응 카디널리티를 갖는다

- 차수에 따른 관계의 종류
  - 단항(Unary) 관계 : 관계에 참여하고 있는 개체 타입이
  1개인 관계
  - 이항(Binary) 관계 : 관계에 참여하고 있는 개체 타입이 2개인 관계
  - 삼항(Ternary) 관계 : 관계에 참여하고 있는 개체 타입 이 3개인 관계
- n항(n-ary) 관계 : 관계에 참여하고 있는 개체 타입이 n개인 관계
- 대응 카디널리티에 따른 관계의 종류
  - 1:1 관계 : 관계에 참여하고 있는 두 개체 타입이 모두
하나씩의 개체 어커런스를 갖는 관계
  - 1:N 관계 : 관계에 참여하고 있는 개체 타입 중 한 개체 타입은 여러 개의 개체 어커런스를 가질 수 있고, 다른 한개체타입은하나의개체어커런스를갖는관계
  - N:M 관계 : 관계에 참여하고 있는 두 개체 타입 모두 여러 개의 개체 어커런스를 가질 수 있는 관계

### 관계 데이터베이스의 Relation 구조
> 릴레이션은 데이터들을 표 형태로 표현한 것. 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구분

<img width="443" alt="image" src="https://user-images.githubusercontent.com/81230679/136559328-74680087-33e1-4fbf-8559-c9e17d4d5577.png">

- 튜플
  - 릴레이션을 구성하는 각각의 행이다. 
  -  속성의 모임으로 구성된다.
  - 파일 구조에서 레코드(Record)와 같은 의미이다.
  - 튜플의 수 = 카디널리티(Cardinality) = 기수 = 대응수
- 속성
  - 릴레이션을 구성하는 각각의 열이다.
  - 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
  - 파일 구조 상의 데이터 항목 또는 데이터 필드에 해당 된다.
  - 개체의 특성을 기술한다. • 속성의 수 = 디그리(Degree) = 차수
- 도메인
  - 하나의  애트리뷰트가  취할  수  있는  같은  타입의  원자 (Atomic)값들의 집합이다.
  - 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를  시스템이 검사하는 데에도 이용된다.
- 릴레이션 인스턴스
  - 데이털 개체를 구성하고 있는 속성들에 데이터 타입이 정의되어 구체적인 데이터 값을 갖고 있는 것

### ER 모델을 관계형 데이터 모델로 변환
- 개념적  데이터  모델인  ER  모델을  논리적  데이터  모 델인  릴레이션  스키마로  변환하는  것으로,  매핑  룰 (Mapping Rule)이라고도 한다.
- 개체 A, B와 관계 Y로 이루어진 ER 모델을 관계형 데 이터  모델에서의  릴레이션  스키마로  변환하는  과정은  다음과 같다.
  - 개체A,B는각각독립적인릴레이션A,B로표현된 다.또한,ER도형에서의각개체의속성들은각릴 레이션의 속성들로 정의되고, 기본키는 밑줄을 그어 표시한다.
  - 관계 Y가 1:1 관계 : 릴레이션 A의 기본키를 릴레이션 B의 외래키로 추가하거나 릴레이션 B의 기본키를 릴 레이션 A의 외래키로 추가하여 표현함
- 관계 Y가 1:N 관계 : 릴레이션 A의 기본키를 릴레이션 B의 외래키로 추가하여 표현함
  - 관계Y가N:M관계:릴레이션A와B의기본키를모두 포함한 별도의 릴레이션으로 표현함

### 키의 개념 및 종류
> 키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성

- 슈퍼키(Super Key) : 한 릴레이션 내에 있는 속성들 의  집합으로  구성된  키로,  릴레이션을  구성하는  모든  튜플에  대해  유일성(Unique)은  만족하지만,  최소성 (Minimality)은 만족하지 못함
- 후보키(Candidate Key) :  릴레이션을  구성하는  속성들  중에서 튜플을 유일하게 식별하기 위해 사용되는 속성 들의 부분집합으로, 유일성과 최소성을 모두 만족함
- 기본키(Primary Key) : 후보키 중에서 특별히 선정된 키 로 중복된 값과 NULL 값을 가질 수 없음
- 대체키(Alternate Key) : 후보키 중에서 선정된 기본키를  제외한 나머지 후보키를 의미함
- 외래키(Foreign Key) : 다른 릴레이션의 기본키를 참조하 는 속성 또는 속성들의 집합을 의미하며, 릴레이션 간 의 관계를 표현할 때 사용함

### 무결성
> DB에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성

- 개체 무결성(Entity Integrity, 실체 무결성) : 기본 테이블의  기본키를 구성하는 어떤 속성도 Null 값이나 중복값을  가질 수 없다는 규정
- 도메인 무결성(Domain Integrity, 영역 무결성) : 주어진 속 성 값이 정의된 도메인에 속한 값이어야 한다는 규정
- 참조 무결성(Referential Integrity) : 외래키 값은 Null이거 나 참조 릴레이션의 기본키 값과 동일해야 함. 즉 릴레 이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
- 사용자 정의 무결성(User-Defined Integrity) : 속성 값들이  사용자가 정의한 제약조건에 만족해야 한다는 규정
- NULL 무결성 : 릴레이션의 특정 속성 값이 NULL이 될  수 없도록 하는 규정
- 고유(Unique) 무결성 : 릴레이션의 특정 속성에 대해 각  튜플이 갖는 속성값들이 서로 달라야 한다는 규정
- 키(Key) 무결성 : 하나의 릴레이션에는 적어도 하나의  키가 존재해야 한다는 규정
- 관계(Relationship) 무결성 : 릴레이션에 어느 한 튜플의  삽입  가능  여부  또는  한  릴레이션과  다른  릴레이션의  튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정

## 네트워크
### 근거리 통신망 LAN
- 회사, 학교, 연구소 등에서 비교적 가까운 거리에 있는 컴퓨터, 프린터, 저장장치 등과 같은 자원을 연결하여 구성한다.
- 사이트 간의 거리가 짧아 데이터의 전송 속도가 빠르 고, 에러 발생율이 낮다.
- 근거리 통신망에서는 주로 버스형이나 링형 구조를 사 용한다.

### 광대역 통신망(WAN; Wide Area Network)
- 국가와 국가 혹은 대륙과 대륙 등과 같이 멀리 떨어진 사이트들을 연결하여 구성한다.
- 사이트 간의 거리가 멀기 때문에 통신 속도가 느리고, 에러 발생률이 높다

### IP주소
- 숫자로 8비트 4부분, 총 32비트로 구성
- 서브넷 마스크 : 4바이트 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트
- 네트워크 부분의 길이에 따라 A-E 클래스까지 총 5단계 구분
<img width="436" alt="image" src="https://user-images.githubusercontent.com/81230679/136565460-7b360ca2-f642-4280-8427-bb75d6bc979e.png">

### IPv6
- 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족
문제를 해결하기위해 개발되었다.
- 16비트씩 8부분, 총 128비트로 구성되어 있다.
- 각 부분을 16진수로 표현하고, 콜론(:)으로 구분한다.
- IPv4에 비해 자료 전송 속도가 빠르고, IPv4와 호환성 이 뛰어나다.
- 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제 를 해결할 수 있다.
- IPv6의 주소 체계
  - 유니캐스트(Unicast) : 단일 송신자와 단일 수신자 간의 통신(1:1 통신에 사용)
  -  멀티캐스트(Multicast) : 단일 송신자와 다중 수신자 간 의 통신(1:N 통신에 사용)
  - 애니캐스트(Anycast) : 단일 송신자와 가장 가까이 있 는 단일 수신자 간의 통신(1:1 통신에 사용)

### OSI 참조 모델
> 다른 시스템 간의 원활한 통신을 위해 ISO에서 제안한 통신규약

- OSI 7계층 : 하위 계층(물리 계층 → 데이터 링크 계층 → 네트워크 계층), 상위 계층(전송 계층 → 세션 계층 → 표현 계층 → 응용 계층)
- 물리 계층(Physical Layer) : 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의함
- 데이터 링크 계층(Data Link Layer)
  - 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 함
  - 흐름 제어, 프레임 동기화, 오류 제어, 순서 제어
- 네트워크 계층(Network Layer, 망 계층)
  - 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 함
  - 경로 설정(Routing), 트래픽 제어, 패킷 정보 전송
- 전송 계층(Transport Layer)
  - 종단 시스템(End-to-End) 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능을 함
  - 주소 설정, 다중화(데이터의 분할과 재조립), 오류 제어, 흐름 제어
- 세션 계층(Session Layer)
  - 송·수신 측 간의 관련성을 유지하고 대화 제어를 담당함
  - 대화(회화) 구성 및 동기 제어, 데이터 교환 관리 기능
- 표현 계층(Presentation Layer)
  - 응용 계층으로부터 받은 데이터를 세션 계층에 맞 게, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능
  - 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식(포맷) 변환, 문맥 관리 기능
- 응용 계층(Application Layer) : 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 응용 프로세스 간의 정 보 교환, 전자 사서함, 파일 전송, 가상 터미널 등의 서 비스를 제공함

### 네트워크 관련 장비
- 허브(Hub)
  - 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각 회선을 통합적으로 관리하며, 신호 증폭 기능을 하는 리피터의 역할도 포함함
  -  더미 허브(Dummy Hub) : 네트워크에 흐르는 모든 데 이터를 단순히 연결하는 기능만을 제공함
  -  스위칭 허브(Switching Hub) : 네트워크상에 흐르는 데 이터의 유무 및 흐름을 제어하여 각각의 노드가 허브 의 최대 대역폭을 사용할 수 있는 지능형 허브임
- 리피터(Repeater) : 물리 계층의 장비로, 전송되는 신호 가 왜곡되거나 약해질 경우 원래의 신호 형태로 재생함
- 브리지(Bridge) : 데이터 링크 계층의 장비로, LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹을 연 결함
- 라우터(Router) : 네트워크 계층의 장비로, LAN과 LAN 의 연결 및 경로 선택, 서로 다른 LAN이나 LAN과 WAN을 연결함
- 게이트웨이(Gateway) : 전 계층(1~7계층)의 프로토콜 구 조가 전혀 다른 네트워크의 연결을 수행함
- 스위치(Switch) : 브리지와 같이 LAN과 LAN을 연결하 여 훨씬 더 큰 LAN을 만드는 장치

<img width="421" alt="image" src="https://user-images.githubusercontent.com/81230679/136567971-670f6783-22e5-4b00-8e25-25557426883b.png">

### TCP / IP
> 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고 받을 수 있도록 하는 표준 프로토콜

#### TCP
- 신뢰성 있는 연결형 서비스를 제공한다.
- 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능 을 제공한다.
- 스트림(Stream) 전송 기능을 제공한다.
#### IP(Internet Protocol)
- 데이터그램을 기반으로 하는 비연결형 서비스를 제공 한다.
- 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공 한다.
- 헤더의 길이는 최소 20Byte에서 최대 60Byte이다.

<img width="434" alt="image" src="https://user-images.githubusercontent.com/81230679/136568574-2718fad0-a6ef-46a5-aa65-75e66b032c35.png">

#### 프로토콜
> 서로 다른 기기들 간 데이터 교환을 원활하게 수행할 수 있도록 표준화 시켜놓은 통신 규약

<img width="425" alt="image" src="https://user-images.githubusercontent.com/81230679/136568498-01a13f4b-9beb-4702-9cff-2249b1b9c648.png">

#### TCP / IP 의 응용 계층 프로토콜
- FTP(File Transfer Protocol) : 컴퓨터와 컴퓨터 또는 컴퓨 터와 인터넷 사이에서 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜
- SMTP(Simple Mail Transfer Protocol) : 전자 우편을 교환 하는 서비스
- TELNET : 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스
- SNMP(Simple Network Management Protocol) : TCP/IP 의 네트워크 관리 프로토콜로, 라우터나 허브 등 네트 워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는 데 사용되는 표준 통신 규약
- DNS(Domain Name System) : 도메인 네임을 IP 주소로 매핑(Mapping)하는 시스템
- HTTP(HyperText Transfer Protocol) : 월드 와이드 웹 (WWW)에서 HTML 문서를 송수신 하기 위한 표준 프 로토콜

#### TCP / IP의 전송 계층 프로토콜
- TCP(Transmission Control Protocol)
  - 양방향 연결(Full Duplex Connection)형 서비스를 제공한다.
  - 가상 회선 연결(Virtual Circuit Connection) 형태 의 서비스를 제공한다.
  - 스트림 위주의 전달(패킷 단위)을 한다.
  - 신뢰성 있는 경로를 확립하고 메시지 전송을 감독한다.
- UDP(User Datagram Protocol)
  - 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공한다.
  - TCP에 비해 상대적으로 단순한 헤더 구조를 가지므 로, 오버헤드가 적다.
  -  고속의안정성있는전송매체를사용하여빠른속 도를필요로하는경우,동시에여러사용자에게데 이터를 전달할 경우, 정기적으로 반복해서 전송할 경우에 사용한다.
  - 실시간 전송에 유리하며, 신뢰성보다는 속도가 중요 시되는 네트워크에서 사용된다.
- RTCP(Real-Time Control Protocol)
  - RTP(Real-time Transport Protocol) 패킷의 전송 품질을 제어하기 위한 제어 프로토콜이다.
  - 세션(Session)에 참여한 각 참여자들에게 주기적으 로 제어 정보를 전송한다.
  - 하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화 (Multiplexing)를 제공한다.

#### TCP / IP의 인터넷 계층 프로토콜
- IP(Internet Protocol) : 전송할 데이터에 주소 지정 및 경 로 설정 등의 기능을 하며, 비연결형인 데이터그램 방 식을 사용하므로 신뢰성이 보장되지 않음
- ICMP(Internet Control Message Protocol) : IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경 등 을 위한 제어 메시지를 관리하는 역할을 하며, 헤더는 8Byte로 구성됨
- IGMP(Internet Group Management Protocol) : 멀티캐스트 를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그 룹 유지를 위해 사용됨
- ARP(Address Resolution Protocol) : 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소 (MAC Address)로 바꿈
- RARP(Reverse Address Resolution Protocol) : ARP와 반 대로 물리적 주소를 IP 주소로 변환하는 기능을 함

#### TCP/IP의 네트워크 액세스 계층 프로 토콜
- Ethernet(IEEE 802.3) : CSMA/CD 방식의 LAN
- IEEE 802 : LAN을 위한 표준 프로토콜
- HDLC : 비트 위주의 데이터 링크 제어 프로토콜 
- X.25 : 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜
- RS-232C : 공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜

### 회선 교환 방식
- 통신을 원하는 두 지점을 교환기를 이용하여 물리적으 로 접속시키는 방식으로, 기존의 음성 전화망이 대표 적이다.
- 접속에는 긴 시간이 소요되나 일단 접속되면 전송 지연 이 거의 없어 실시간 전송이 가능하다.
- 데이터 전송에 필요한 전체 시간이 축적 교환 방식에 비해 길다.
- 일정한 데이터 전송률을 제공하므로 동일한 전송 속도 가 유지된다.
- 회선 교환 방식의 종류
  -  공간 분할 교환 방식(SDS; Space Division Switching) : 기 계식 접점과 전자 교환기의 전자식 접점 등을 이용하 여 교환을 수행하는 방식으로, 음성 전화용 교환기가 이에 속함
-  시분할 교환 방식(TDS; Time Division Switching) : 전자 부 품이 갖는 고속성과 디지털 교환 기술을 이용하여 다 수의 디지털 신호를 시분할적으로 동작시켜 다중화 하는 방식

### 패킷 교환 방식
- 메시지를 일정한 길이의 패킷으로 잘라서 전송하는 방식이다.
- 패킷은 장애 발생 시의 재전송을 위해 패킷 교환기에 일 시 저장되었다가 곧 전송되며 전송이 끝난 후 폐기된다.
- 전송 시 교환기, 회선 등에 장애가 발생하더라도 다른 정상적인 경로를 선택해서 우회할 수 있다.
- 음성 전송보다 데이터 전송에 더 적합하다.
- 패킷 교환망은 OSI 7계층의 네트워크 계층에 해당한다. •패킷 교환 방식의 종류
  -  가상 회선 방식 : 단말장치 상호간에 논리적인 가상 통신 회선을 미리 설정하여 송신지와 수신지 사이의 연결을 확립한 후에 설정된 경로를 따라 패킷들을 순 서적으로 운반하는 방식
  -  데이터그램 방식 : 연결 경로를 설정하지 않고 인접한 노드들의 트래픽(전송량) 상황을 감안하여 각각의 패 킷들을 순서에 상관없이 독립적으로 운반하는 방식

### 라우팅(경로 제어)
- 송·수신 측 간의 전송 경로 중에서 최적 패킷 교환 경로를 결정하는 기능이다.
- 경로 제어표(Routing Table)를 참조해서 이루어지며, 라우터에 의해 수행된다.
- 라우팅 프로토콜
  -  RIP(Routing Information Protocol) : 현재 가장 널리 사용 되는 라우팅 프로토콜로, 소규모 동종의 네트워크 내 에서 효율적인 방법이며, 최대 홉수를 15로 제한함
  - IGRP(Interior Gateway Routing Protocol) : RIP의 단점을 보완하기 위해 만들어 개발된 것으로, 네트워크 상태 를 고려하여 라우팅하며, 중규모 네트워크에 적합함
  -  OSPF(Open Shortest Path First Protocol) : 대규모 네트 워크에서 많이 사용되는 라우팅 프로토콜로, 라우팅 정보에 변화가 생길 경우 변화된 정보만 네트워크 내 의 모든 라우터에 알리며, RIP에 비해 홉수에 제한 이 없음
  -  BGP(Border Gateway Protocol) : 자율 시스템(AS) 간의 라우팅 프로토콜로, EGP의 단점을 보완하기 위해 개발되었음
- 라우팅 알고리즘
  -  거리 벡터 알고리즘(Distance Vector Algorithm) : 인접해 있는 라우터 간의 거리(Distance)와 방향(Vector)에 대한 정보를 이용하여 최적의 경로를 찾고 그 최적 경로를 이용할 수 없을 경우 다른 경로를 찾는 알고 리즘으로, RIP와 IGRP가 있음
  -  링크 상태 알고리즘(Link State Algorithm) : 라우터와 라 우터 간의 모든 경로를 파악하여 미리 대체 경로를 마련해 두는 알고리즘으로, 거리 벡터 알고리즘의 단점을 보완하기 위해 개발되었으며, OSPF가 있음

# 제품 소프트웨어 패키징
## 소프트웨어 패키징
> 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것

- 개발자가 아니라 사용자 중심으로 진행
- 소스코드는 향후 관리를 고려해 모듈화해 패키징
- 작업 순서 : 기능 식별 → 모듈화 (Modularity) → 빌드(Build) 진행 → 사용자 환경 분석  → 패키징 및 적용 시험 → 패키징 변경 개선 → 배포

## 릴리즈 노트
> 개발 과정에서 정리된 릴리즈 정보를 소프트웨어 최종 사용자인 고객과 공유하기 위한 문서

❶  모듈 식별 : 모듈별 빌드 수행 후 릴리즈 노트에 작성 될 내용 확인
❷  릴리즈 정보 확인 : 릴리즈 노트 및 소프트웨어 이름, 릴리즈 버전 및 날짜, 노트 날짜 및 버전 등 확인
❸  릴리즈 노트 개요 작성 : 소프트웨어 및 변경사항 전 체에 대한 간략한 내용 작성
❹  영향도 체크 : 버그나 이슈 관련 내용 또는 해당 릴리 즈 버전에서의 기능 변화가 다른 소프트웨어나 기능 을 사용하는데 미칠 수 있는 영향 기술
❺  정식 릴리즈 노트 작성 : Header(머릿말), 개요, 영향 도 체크 항목을 포함하여 정식 릴리즈 노트에 작성 될 기본 사항 작성
❻  추가 개선 항목 식별 : 추가 버전 릴리즈 노트 작성이 필요한 경우 추가 릴리즈 노트 작성
※  Header(머릿말) : 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 날짜, 릴리즈 노트 날짜, 릴리즈 노트 버전 등을 표시함

## 디지털 저작권 관리
> 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용 까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술

### 디지털 저작권 관리의 기술 요소
-  암호화(Encryption) : 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술
-  키 관리(Key Management) : 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술
- 암호화 파일 생성(Packager) : 콘텐츠를 암호화된 콘텐 츠로 생성하기 위한 기술
- 식별기술(Identification)  : 콘텐츠에 대한 식별 체계 표 현 기술
-  저작권 표현(Right Expression) : 라이선스의 내용 표현 기술
-  정책 관리(Policy Management) : 라이선스 발급 및 사용 에 대한 정책 표현 및 관리 기술
-  크랙 방지(Tamper Resistance) : 크랙에 의한 콘텐츠 사 용 방지 기술
-  인증(Authentication) : 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술

## 소프트웨어 설치 메뉴얼 작성
> 개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서

❶  기능 식별 : 소프트웨어의 개발 목적과 주요 기능을흐름 순으로 정리하여 기록
❷  UI 분류 : 설치 매뉴얼을 작성할 순서대로 UI를 분류 한 후 기록
❸  설치 파일/백업 파일 확인 : 폴더 위치, 설치 파일, 백 업 파일 등의 개별적인 기능을 확인하여 기록
❹  Uninstall 절차 확인 : 직접 Uninstall을 수행하면서 그 순서를 단계별로 자세히 기록
❺  이상 Case 확인 : 설치 과정에서 발생할 수 있는 다 양한 Case를 만들어 확인하고 해당 Case에 대한 대 처법을 자세하게 기록
❻  최종 매뉴얼 적용 : 설치가 완료된 화면과 메시지를 캡쳐하여 추가한 후 완성된 매뉴얼을 검토하고 고객 지원에 대한 내용 기록

### 소프트웨어 사용자 메뉴얼 작성
> 소프트웨어 사용자 메뉴얼은 사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 문서로 기록한 설명서와 안내서

❶  기능 식별 : 소프트웨어의 개발 목적과 사용자 활용
기능을 흐름 순으로 정리하여 기록
❷  사용자 화면 분류 : 사용자 화면을 메뉴별로 분류하여 기록
❸  사용자 환경 파일 확인 : 폴더 위치, 사용자 로그 파 일, 백업 파일 등의 개별적인 기능을 확인하여 기록
❹  초기화 절차 확인 : 프로그램을 사용하기 위한 초기화 절차를 확인하고 그 단계를 순서대로 기록
❺  이상 Case 확인 : 소프트웨어 사용 과정에서 발생할 수 있는 다양한 이상 Case를 만들어 확인하고 해당 Case에 대한 대처법을 자세하게 기록
❻  최종 매뉴얼 적용 : 사용과 관련된 문의 답변(FAQ)을 기록한 후 완성된 매뉴얼을 검토하고 고객 지원에 대한 내용 기록

## 소프트웨어 패키징의 형상 관리(SCM)
> 형상 관리(SCM; Software Configuration Management) 는 소프트웨어의 개발 과정에서 소프트웨어의 변경 사 항을 관리하기 위해 개발된 일련의 활동이다.

### 형상 관리의 기능
-  형상 식별 : 형상 관리 대상에 이름과 관리 번호를 부 여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
-  버전 제어 : 소프트웨어 업그레이드나 유지 보수 과정 에서 생성된 다른 버전의 형상 항목을 관리하고, 이 를 위해 특정 절차와 도구(Tool)를 결합시키는 작업
-  형상 통제(변경 관리) : 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(Base Line)이 잘 반 영될 수 있도록 조정하는 작업
-  형상 감사 : 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
-  형상 기록(상태 보고) : 형상의 식별, 통제, 감사 작업 의 결과를 기록·관리하고 보고서를 작성하는 작업

## 소프트웨어 버전 등록 과정
❶  가져오기(Import) : 개발자가 저장소에 신규로 파일을 추가함
❷  인출(Check-Out)  : 수정 작업을 진행할 개발자가 저장 소에 추가된 파일을 자신의 작업 공간으로 인출함
❸  예치(Commit) : 인출한 파일을 수정한 후 설명을 붙여 저장소에 예치함
❹  동기화(Update) : 커밋(Commit) 후 새로운 개발자가 자 신의 작업 공간을 동기화(Update)함
❺  차이(Diff) : 새로운 개발자가 추가된 파일의 수정 기록 (Change Log)을 확인하면서 이전 개발자가 처음 추가 한 파일과 이후 변경된 파일의 차이를 확인함

### 소프트웨어 버전 관리 도구
- 공유 폴더 방식 : 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식
- 클라이언트/서버 방식 : 버전 관리 자료가 중앙 시스템 (서버)에 저장되어 관리되는 방식
- 분산 저장소 방식 : 버전 관리 자료가 하나의 원격 저장 소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되 어 관리되는 방식
- Subversion(SVN) : CVS(Concurrent Version System) 를 개선한 것으로, 클라이언트/서버 구조이며, 아파치  소프트웨어 재단에서 2000년에 발표하였음
- Git : 리누스 토발즈(Linus Torvalds)가 2005년 리눅스  커널  개발에  사용할  관리  도구로  개발한  이후  주니오  하마노(Junio Hamano)에 의해 유지 보수되고 있음

<img width="416" alt="image" src="https://user-images.githubusercontent.com/81230679/136571342-342a74c1-8c69-4140-bf60-990d6a0f0c2c.png">

## 빌드 자동화 도구
> 빌드는 소스 코드 파일들을 컴파일 한 후 여러 개의 모듈을 묶어 실행 파일로 만드는 과정이며, 이러한 빌드를 포함해 테스트 및 배포를 자동화하는 도구를 빌드 자동화도구라고 함

### Jenkins
- Java 기반의 오픈 소스 형태로, 가장 많이 사용되는 빌 드 자동화 도구이다.
- 서블릿 컨테이너에서 실행되는 서버 기반 도구이다.
- SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능 하다.
- 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트가 가능 하다.

### Gradle
- Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구 로, 안드로이드 앱 개발 환경에서 사용된다.
- 안드로이드  뿐만  아니라  플러그인을  설정하면,  Java,  C/C++, Python 등의 언어도 빌드가 가능하다.
- Groovy를  사용해서  만든  DSL(Domain  Specific  Language)을 스크립트 언어로 사용한다.
- Gradle은 실행할 처리 명령들을 모아 태스크(Task)로  만든 후 태스크 단위로 실행한다.