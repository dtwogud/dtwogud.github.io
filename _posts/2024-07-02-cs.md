---
title : "[CS] 디자인 패턴과 프로그래밍 패러다임"
excerpt: "자바스크립트로 공부하는 디자인 패턴"

categories:
  - etc
tags:
  - [CS, JS, Design Pattern]

toc: true
toc_sticky: true

date: 2024-07-05
last_modified_at: 2024-07-05
---
<br>

## 디자인 패턴

> 프로그램을 설계할 때 발생했던 문제점들을 객체 간 상호 관계 등을 이용해 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것

### ㅁ 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스(클래스에 소속된 개별적인 객체)만 자기는 패턴. 보통 데이터베이스 연결 모듈에 많이 사용한다.
<br/>
인스턴스를 생성할 때 드는 비용이 줄어드는 장점과 의존성이 높아진다는 단점이 특징이다.

JS에서는 리터럴 {} 또는 new Object로 객체를 생성하게 되면 다른 어떤 객체와도 같지 않기 때문에 이를 이용해 싱글톤 패턴을 구현한다.

```js
const obj = {
  a: 27
}
const obj2 = {
  b: 27
}

console.log(obj === obj2)
//false
```

```js
class Singleton {
    constructor() {
        if (!Singleton.instance) {
            Singleton.instance = this
        }
        return Singleton.instance
    }
    getInstance() {
        return this 
    }
}
const a = new Singleton()
const b = new Singleton() 
console.log(a === b)
// true 
//a와 b는 하나의 인스턴스를 가진다.
```

<br/>

#### 싱글톤 패턴 > 데이터베이스 연결 모듈
DB.instance라는 하나의 인스턴스를 기반으로 a,b를 생성. 데이터베이스 연결에 관한 인스턴스 생성 비용 절감 효과.

```js
// DB 연결을 하는 것이기 때문에 비용이 더 높은 작업 
const URL = 'mongodb://localhost:27017/kundolapp' 
const createConnection = url => ({"url" : url})    
class DB {
    constructor(url) {
        if (!DB.instance) { 
            DB.instance = createConnection(url)
        }
        return DB.instance
    }
    connect() {
        return this.instance
    }
}
const a = new DB(URL)
const b = new DB(URL) 
console.log(a === b) // true
```
<br/>

#### 싱글톤 패턴의 단점

- 싱글톤 패턴은 TDD(Test Driven Development)를 할 때 걸림돌이 된다. 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 '독립적인' 인스턴스를 만들기가 어렵다.
- 모듈 간의 결합을 강하게 만들 수 있다. 이를 위해 의존성 주입(DI, Dependency Injection)을 통해 모듈 간 결합을 조금 더 느슨하게 만들어 해결 할 수 있다.

<br/>

##### 싱글톤 패턴 > 의존성 주입

메인 모듈과 다른 하위 모듈 사이에 의존성 주입자를 배치해 간접적으로 의존성을 주입하는 방식. 메인 모듈(상위 모듈)은 하위 모듈에 대한 의존성이 떨어지게 되는 '디커플링'이 된다.

- 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션도 수원해지지만
- 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며 런타임 패널티가 생기기도 한다.


### ㅁ 팩토리 패턴

객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴. 상위 클래스가 중요한 뼈대를 결정, 하위 클래스에서 객체 생성에 관한 구체적 내용 결정.

상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 가진다. 객체 생성 로직이 따로 떼어져 있기에 유지 보수성이 증가한다.

마찬가지로 new Object()로 구현 가능하다.

```js
const num = new Object(42)
const str = new Object('abc')
num.constructor.name //Number
str.constructor.name //String
```

```js
class CoffeeFactory {
    static createCoffee(type) {
        const factory = factoryList[type]
        return factory.createCoffee()
    }
}   
class Latte {
    constructor() {
        this.name = "latte"
    }
}
class Espresso {
    constructor() {
        this.name = "Espresso"
    }
} 

class LatteFactory extends CoffeeFactory{
    static createCoffee() {
        return new Latte()
    }
}
class EspressoFactory extends CoffeeFactory{
    static createCoffee() {
        return new Espresso()
    }
}
const factoryList = { LatteFactory, EspressoFactory } 
 
 
const main = () => {
    // 라떼 커피를 주문한다.  
    const coffee = CoffeeFactory.createCoffee("LatteFactory")  
    // 커피 이름을 부른다.  
    console.log(coffee.name) // latte
}
main()
```

CoffeeFactory라는 상위 클래스가 중요한 뼈대를 결정, 하위 클래스가 구체적인 내용을 결정하고 있다.


CoffeeFactory에서 LatteFactory의 인스턴스를 생서하는 것이 아닌 LatteFactory에서 생성한 인스턴스를 CoffeeFactory에 주입하고 있기에 의존성 주입이라고도 볼 수 있다.

** CoffeeFactory클래스를 보면 static 키워드를 통해 createCoffee() 메서드를 정적메서드로 선언하면 클래스를 기반으로 객체를 만들지 않고 호출이 가능하며, 해당 메서드에 대한 메모리 할당을 한 번만 할 수 있는 자점이 있다. **


