---
title : "[CS] 디자인 패턴과 프로그래밍 패러다임"
excerpt: "자바스크립트로 공부하는 디자인 패턴"

categories:
  - etc
tags:
  - [CS, JS, Design Pattern]

toc: true
toc_sticky: true

date: 2024-07-05
last_modified_at: 2024-07-05
---
<br>

## 디자인 패턴

> 프로그램을 설계할 때 발생했던 문제점들을 객체 간 상호 관계 등을 이용해 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것

### ㅁ 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스(클래스에 소속된 개별적인 객체)만 자기는 패턴. 보통 데이터베이스 연결 모듈에 많이 사용한다.
<br/>
인스턴스를 생성할 때 드는 비용이 줄어드는 장점과 의존성이 높아진다는 단점이 특징이다.

JS에서는 리터럴 {} 또는 new Object로 객체를 생성하게 되면 다른 어떤 객체와도 같지 않기 때문에 이를 이용해 싱글톤 패턴을 구현한다.

```js
const obj = {
  a: 27
}
const obj2 = {
  b: 27
}

console.log(obj === obj2)
//false
```

```js
class Singleton {
    constructor() {
        if (!Singleton.instance) {
            Singleton.instance = this
        }
        return Singleton.instance
    }
    getInstance() {
        return this 
    }
}
const a = new Singleton()
const b = new Singleton() 
console.log(a === b)
// true 
//a와 b는 하나의 인스턴스를 가진다.
```

<br/>

#### 싱글톤 패턴 > 데이터베이스 연결 모듈
DB.instance라는 하나의 인스턴스를 기반으로 a,b를 생성. 데이터베이스 연결에 관한 인스턴스 생성 비용 절감 효과.

```js
// DB 연결을 하는 것이기 때문에 비용이 더 높은 작업 
const URL = 'mongodb://localhost:27017/kundolapp' 
const createConnection = url => ({"url" : url})    
class DB {
    constructor(url) {
        if (!DB.instance) { 
            DB.instance = createConnection(url)
        }
        return DB.instance
    }
    connect() {
        return this.instance
    }
}
const a = new DB(URL)
const b = new DB(URL) 
console.log(a === b) // true
```
<br/>

#### 싱글톤 패턴의 단점

- 싱글톤 패턴은 TDD(Test Driven Development)를 할 때 걸림돌이 된다. 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 '독립적인' 인스턴스를 만들기가 어렵다.
- 모듈 간의 결합을 강하게 만들 수 있다. 이를 위해 의존성 주입(DI, Dependency Injection)을 통해 모듈 간 결합을 조금 더 느슨하게 만들어 해결 할 수 있다.

<br/>

##### 싱글톤 패턴 > 의존성 주입

메인 모듈과 다른 하위 모듈 사이에 의존성 주입자를 배치해 간접적으로 의존성을 주입하는 방식. 메인 모듈(상위 모듈)은 하위 모듈에 대한 의존성이 떨어지게 되는 '디커플링'이 된다.

- 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션도 수원해지지만
- 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며 런타임 패널티가 생기기도 한다.

[//]: # (<br/>)

#### 스레스세이프(thread safe)
다중 스레드 환경에서 코드나 프로그램이 동작할 때 여러 스레드가 동시에 접근하거나 수정하더라도 예기치 않은 동작이나 데이터 손상이 발생하지 않는 특성.

Enum을 기반으로 상수 집합을 관리하면 코드를 리팩터링할 때 상수 집합에 대한 로직 수정 시 이 부분만 수정하면 된다는 장점이 있고, 본질적으로 스레드 세이프 하기 때문에 싱글톤 패턴을 만들 때 도움이 된다.

<br/>

### ㅁ 팩토리 패턴

객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴. 상위 클래스가 중요한 뼈대를 결정, 하위 클래스에서 객체 생성에 관한 구체적 내용 결정.

상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 가진다. 객체 생성 로직이 따로 떼어져 있기에 유지 보수성이 증가한다.

마찬가지로 new Object()로 구현 가능하다.

```js
const num = new Object(42)
const str = new Object('abc')
num.constructor.name //Number
str.constructor.name //String
```

```js
class CoffeeFactory {
    static createCoffee(type) {
        const factory = factoryList[type]
        return factory.createCoffee()
    }
}   
class Latte {
    constructor() {
        this.name = "latte"
    }
}
class Espresso {
    constructor() {
        this.name = "Espresso"
    }
} 

class LatteFactory extends CoffeeFactory{
    static createCoffee() {
        return new Latte()
    }
}
class EspressoFactory extends CoffeeFactory{
    static createCoffee() {
        return new Espresso()
    }
}
const factoryList = { LatteFactory, EspressoFactory } 
 
 
const main = () => {
    // 라떼 커피를 주문한다.  
    const coffee = CoffeeFactory.createCoffee("LatteFactory")  
    // 커피 이름을 부른다.  
    console.log(coffee.name) // latte
}
main()
```

CoffeeFactory라는 상위 클래스가 중요한 뼈대를 결정, 하위 클래스가 구체적인 내용을 결정하고 있다.


CoffeeFactory에서 LatteFactory의 인스턴스를 생성하는 것이 아닌 LatteFactory에서 생성한 인스턴스를 CoffeeFactory에 주입하고 있기에 의존성 주입이라고도 볼 수 있다.

** CoffeeFactory클래스를 보면 static 키워드를 통해 createCoffee() 메서드를 정적메서드로 선언하면 클래스를 기반으로 객체를 만들지 않고 호출이 가능하며, 해당 메서드에 대한 메모리 할당을 한 번만 할 수 있는 자점이 있다. **

<br/>

### ㅁ 전략 패턴

정책 패턴(policy pattern)이라고도 하며 객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

<br/>

#### 컨텍스트
개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보

<br/>

#### 전략 패턴 > passport

Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로 여러가지 전략을 기반으로 인증할 수 있게 한다.

```js
var passport = require('passport')
    , LocalStrategy = require('passport-local').Strategy;

passport.use(new LocalStrategy(
    function(username, password, done) {
        User.findOne({ username: username }, function (err, user) {
          if (err) { return done(err); }
            if (!user) {
                return done(null, false, { message: 'Incorrect username.' });
            }
            if (!user.validPassword(password)) {
                return done(null, false, { message: 'Incorrect password.' });
            }
            return done(null, user);
        });
    }
));
```

passport.use(new LocalStrategy(...)) 처럼 passport.use()라는 메서드에 전략을 매개변수로 넣어서 로직을 수행한다.

